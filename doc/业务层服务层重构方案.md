好的，没问题！我们来制定一个极其详细的、按部就班的重构计划，目标是让初级开发者也能清晰地理解并执行。

**重构目标:**

* **职责清晰:** 每个模块/文件只做一件事。
* **依赖明确:** 减少不必要的直接依赖，通过清晰的服务接口交互。
* **代码一致:** 统一处理平台差异、文件操作、数据转换的方式。
* **可测试性:** 使核心逻辑单元（如数据处理、文件保存、加载）更易于独立测试。
* **可维护性:** 代码结构更清晰，未来修改或添加功能更容易。

**重要提示给执行者 (实习生):**

* **小步提交:** 每完成一个主要步骤（或几个小步骤），都进行代码提交 (git commit)，这样如果出错可以方便地回滚。
* **测试验证:** 在关键步骤后（尤其是修改了核心功能如加载、保存、增删改后），手动运行应用，测试相关功能是否正常工作。
* **理解目的:** 不仅仅是复制代码，尝试理解每一步重构是为了解决什么问题。
* **仔细检查:** 修改代码后，仔细检查相关的导入路径、函数调用、变量名是否都已更新。
* **寻求帮助:** 如果遇到困难或不确定的地方，及时提问。

---

**详细重构步骤:**

**第一阶段：建立统一的平台服务层**

* **目的:** 消除 `fileService.ts`, `dialogService.ts` 的混乱，强制所有平台相关操作通过统一接口。
* **步骤:**
    1.  **创建 `platformService.ts`:**
        * 在 `src/services/` 目录下创建新文件 `platformService.ts`。
        * 拷贝以下基础代码到 `platformService.ts`:
            ```typescript
            import { PlatformAdapterFactory } from './platform/PlatformAdapterFactory';
            import type { IPlatformAdapter } from './platform/IPlatformAdapter';
            import type {
              OpenDialogOptions, OpenDialogResult, FileInfo,
              SaveDialogOptions, SaveDialogResult, MessageBoxOptions,
              MessageBoxResult, YamlData
            } from '@/types/preload';
            import type { EspansoFile } from '@/types/espanso-config';

            // 获取平台适配器实例
            const adapter: IPlatformAdapter = PlatformAdapterFactory.getInstance();

            // 导出所有平台接口方法，内部调用适配器实例
            export const platformService = {
              readFile: (filePath: string): Promise<string> => adapter.readFile(filePath),
              writeFile: (filePath: string, content: string): Promise<void> => adapter.writeFile(filePath, content),
              fileExists: (filePath: string): Promise<boolean> => adapter.fileExists(filePath),
              listFiles: (dirPath: string): Promise<FileInfo[]> => adapter.listFiles(dirPath),
              showOpenDialog: (options: OpenDialogOptions): Promise<OpenDialogResult> => adapter.showOpenDialog(options),
              showOpenDirectoryDialog: (): Promise<string | null> => adapter.showOpenDirectoryDialog(),
              showSaveDialog: (options: SaveDialogOptions): Promise<SaveDialogResult> => adapter.showSaveDialog(options),
              showMessageBox: (options: MessageBoxOptions): Promise<MessageBoxResult> => adapter.showMessageBox(options),
              getPlatform: (): Promise<string> => adapter.getPlatform(),
              parseYaml: (content: string): Promise<YamlData> => adapter.parseYaml(content),
              serializeYaml: (data: YamlData): Promise<string> => adapter.serializeYaml(data),
              getEspansoConfigDir: (): Promise<string | null> => adapter.getEspansoConfigDir(),
              getEspansoConfigFiles: (): Promise<EspansoFile[]> => adapter.getEspansoConfigFiles(),
              showNotification: (title: string, body: string): Promise<void> => adapter.showNotification(title, body),
              saveConfigDirPath: (path: string): void => adapter.saveConfigDirPath(path),
              getConfigDirPath: (): string | null => adapter.getConfigDirPath(),

              // --- 以下是可能在 preloadApi 但不在 IPlatformAdapter 中的补充 ---
              // --- 确保这些方法在 ElectronAdapter 中实现并在 IPlatformAdapter 中定义 ---

              // 示例：如果 renameFile 只在 preloadApi 有
              renameFile: async (oldPath: string, newPath: string): Promise<void> => {
                // 需要确保 ElectronAdapter 和 IPlatformAdapter 中有 renameFile
                if ('renameFile' in adapter && typeof adapter.renameFile === 'function') {
                    return adapter.renameFile(oldPath, newPath);
                } else {
                    console.error('platformService: renameFile is not implemented in the current adapter.');
                    return Promise.reject(new Error('renameFile not implemented'));
                }
              },
              // 示例：如果 scanDirectory 只在 preloadApi 有
              scanDirectory: async (dirPath: string): Promise<any[]> => {
                 // 需要确保 ElectronAdapter 和 IPlatformAdapter 中有 scanDirectory
                 if ('scanDirectory' in adapter && typeof adapter.scanDirectory === 'function') {
                    return adapter.scanDirectory(dirPath);
                 } else {
                    console.error('platformService: scanDirectory is not implemented in the current adapter.');
                     return Promise.reject(new Error('scanDirectory not implemented'));
                 }
              },
               // 示例：如果 deleteFile 只在 preloadApi 有
              deleteFile: async (filePath: string): Promise<void> => {
                 // 需要确保 ElectronAdapter 和 IPlatformAdapter 中有 deleteFile
                 if ('deleteFile' in adapter && typeof adapter.deleteFile === 'function') {
                    return adapter.deleteFile(filePath);
                 } else {
                    console.error('platformService: deleteFile is not implemented in the current adapter.');
                     return Promise.reject(new Error('deleteFile not implemented'));
                 }
              },
               // 示例：如果 removeDirectory 只在 preloadApi 有
              removeDirectory: async (dirPath: string): Promise<void> => {
                 // 需要确保 ElectronAdapter 和 IPlatformAdapter 中有 removeDirectory
                 if ('removeDirectory' in adapter && typeof adapter.removeDirectory === 'function') {
                    return adapter.removeDirectory(dirPath);
                 } else {
                    console.error('platformService: removeDirectory is not implemented in the current adapter.');
                     return Promise.reject(new Error('removeDirectory not implemented'));
                 }
              },
               // 示例: path.join (如果需要跨平台路径拼接)
               joinPath: async (...paths: string[]): Promise<string> => {
                 // 需要确保 ElectronAdapter 和 IPlatformAdapter 中有 joinPath
                 if ('joinPath' in adapter && typeof adapter.joinPath === 'function') {
                    return adapter.joinPath(...paths);
                 } else {
                    // 提供一个基础的回退实现
                    console.warn('platformService: joinPath not implemented in adapter, using simple join.');
                    return Promise.resolve(paths.join('/')); // 注意：这在 Windows 上可能不正确
                 }
               }
            };
            ```
    2.  **更新 `IPlatformAdapter.ts`:**
        * 打开 `src/services/platform/IPlatformAdapter.ts`。
        * 确保接口中**包含** `platformService.ts` 中需要的所有方法签名，特别是那些可能只在 `preloadApi` 中存在的补充方法（如 `renameFile`, `scanDirectory`, `deleteFile`, `removeDirectory`, `joinPath` 等）。如果缺少，请添加。WebAdapter 对于这些方法可以继续返回 `Promise.reject` 或模拟行为。
        * 示例（添加缺失的方法）：
            ```typescript
            export interface IPlatformAdapter {
              // ... (已有方法) ...

              // --- 新增或确认存在的方法 ---
              renameFile(oldPath: string, newPath: string): Promise<void>;
              scanDirectory(dirPath: string): Promise<any[]>;
              deleteFile(filePath: string): Promise<void>;
              removeDirectory(dirPath: string): Promise<void>;
              joinPath(...paths: string[]): Promise<string>; // 路径拼接
            }
            ```
    3.  **更新 `ElectronAdapter.ts` 和 `WebAdapter.ts`:**
        * 确保这两个文件都实现了 `IPlatformAdapter` 接口中**所有**的方法。
        * 对于 `ElectronAdapter`，如果之前缺少某些方法（如 `renameFile`），现在需要添加并调用对应的 `this.preloadApi.renameFile`。
        * 对于 `WebAdapter`，为新增的接口方法提供模拟实现或拒绝执行（例如 `return Promise.reject(new Error('scanDirectory not available in web'))`）。
    4.  **替换全局调用:**
        * **搜索**整个项目（`.vue`, `.ts` 文件），查找所有 `window.preloadApi` 的使用。
        * **保留** `src/services/platform/ElectronAdapter.ts` 内部对 `window.preloadApi` 的使用。
        * **替换**所有其他地方对 `window.preloadApi.someFunction(...)` 的调用，改为 `platformService.someFunction(...)`。例如，`window.preloadApi.readFile(path)` 变为 `platformService.readFile(path)`。
        * **搜索**整个项目，查找所有对 `fileService.ts` 或 `dialogService.ts` 中导出函数（如 `readFile`, `writeFile`, `showOpenDirectoryDialog`, `showErrorDialog` 等）的调用。
        * **替换**这些调用为对 `platformService` 相应方法的调用。例如，旧的 `readFile(path)` 变为 `platformService.readFile(path)`，旧的 `showOpenDirectoryDialog()` 变为 `platformService.showOpenDirectoryDialog()`。
    5.  **删除旧文件:**
        * 确认所有依赖都已更新后，**删除** `src/services/fileService.ts` 和 `src/services/dialogService.ts`。
    6.  **测试:** 运行应用，测试基本的文件加载、目录选择、可能的文件操作等功能是否仍然正常工作。

**第二阶段：整合数据转换工具**

* **目的:** 消除 `espanzo-utils.ts` 的冗余，统一数据转换逻辑。
* **步骤:**
    1.  **确定主文件:** 选择 `src/utils/espanso-converter.ts` 作为保留和整合的目标文件。
    2.  **检查冗余文件:** 打开 `src/utils/espanzo-utils.ts`。查看其中的函数：
        * `generateId`: `espanso-converter` 中已有类似功能（或可直接使用 `uuidv4`）。
        * `parseYaml`, `serializeYaml`: 已废弃，应使用 `platformService`。
        * `convertToInternalFormat`, `convertToEspansoFormat`: `espanso-converter` 中有更完善的版本。
        * `addIdsAndTimestamps`: `espanso-converter` 中有。
        * `walkTree`, `findItemById`, `removeItemById`, `insertItemAtIndex`, `getAllGroups`: 这些似乎是针对 `espanzo-utils` 定义的旧的、可能不完整的内部格式 (`EspansoConfig` 等类型定义在 `types/espanso-config.ts`，这个文件也可能需要清理或与 `types/espanso.ts` 合并)。**除非你确认这些函数对当前的 `useEspansoStore` 逻辑有用，否则大概率可以直接删除 `espanzo-utils.ts`。**
        * `getAvailableVariables`: 可能是有效的辅助函数，可以考虑移动到 `espanso-converter.ts` 或其他合适的位置。
        * `generatePreview`: 可能是有效的辅助函数，可以考虑移动。
    3.  **整合 (如果需要):** 如果 `espanzo-utils.ts` 中有需要保留的函数（如 `getAvailableVariables`, `generatePreview`），将它们**复制**到 `espanso-converter.ts` 中。
    4.  **更新 `espanso-converter.ts`:**
        * 确保此文件不再直接调用 `preloadApi` 或 `js-yaml` 进行 YAML 操作。如果内部有相关逻辑，修改为调用 `platformService.parseYaml` 和 `platformService.serializeYaml`。（当前代码似乎没有直接调用，是好的）。
        * 检查并统一 ID 生成方式（推荐直接使用 `uuidv4` 或 `espansoDataUtils.ts` 中的 `generateId`）。
    5.  **删除冗余文件:** **删除** `src/utils/espanzo-utils.ts` 和可能不再使用的 `src/types/espanso-config.ts` (请仔细确认类型定义是否已在 `src/types/espanso.ts` 或其他地方覆盖)。
    6.  **更新导入:** 搜索并更新项目中所有对已删除文件或其中函数的导入引用。

**第三阶段：重构 `useContextMenu` Hook**

* **目的:** 使 Hook 专注于 UI 交互，将业务逻辑和副作用移交给 Store。
* **步骤:**
    1.  **处理 `handleCreateConfigFile`:**
        * 在 `src/store/useEspansoStore.ts` 中，添加一个新的 Action：
            ```typescript
            // 在 useEspansoStore return 对象中添加
            createConfigFile: async (folderPath: string) => {
              console.log(`[Store] Action: createConfigFile in folder: ${folderPath}`);
              state.value.loading = true; // 可选：显示加载状态
              try {
                const timestamp = Date.now();
                const newFileName = `config_${timestamp}.yml`;
                // 使用 platformService 进行路径拼接
                const newFilePath = await platformService.joinPath(folderPath, newFileName);
                const matchId = `match-${timestamp}`;
                const defaultContent = { /* ... (复制 handleCreateConfigFile 中的默认内容) ... */ };
                const yamlContent = await platformService.serializeYaml(defaultContent);
                await platformService.writeFile(newFilePath, yamlContent);

                // 重新加载配置
                if (state.value.configRootDir) {
                  await loadConfig(state.value.configRootDir); // 调用 store 内部的 loadConfig
                  // 成功提示现在应在 Action 完成后由调用处（ContextMenu）处理，或 Action 返回成功状态
                  console.log(`[Store] Config file ${newFileName} created and config reloaded.`);

                  // 返回新创建的 Match ID 以便选中
                   return { success: true, matchIdToSelect: matchId };
                } else {
                  console.error('[Store] Cannot reload config, configRootDir is null.');
                  throw new Error('无法重新加载配置，根目录未知');
                }
              } catch (error: any) {
                console.error('[Store] 创建配置文件失败:', error);
                state.value.error = `创建配置文件失败: ${error.message || '未知错误'}`;
                 return { success: false, error: state.value.error };
              } finally {
                state.value.loading = false;
              }
            },
            ```
        * 修改 `src/hooks/useContextMenu.ts` 中的 `handleCreateConfigFile`:
            ```typescript
            const handleCreateConfigFile = async () => {
              const node = getCurrentNode();
              if (!node || node.type !== 'folder' || !node.path) {
                 toast.error('请选择一个文件夹节点来创建配置文件');
                 return;
               }
              const folderPath = node.path;

              // 调用 Store Action
              const result = await store.createConfigFile(folderPath);

              if (result.success && result.matchIdToSelect) {
                  toast.success(`配置文件已创建`);
                   // 选中新创建的片段
                   setTimeout(() => {
                     store.state.selectedItemId = result.matchIdToSelect;
                     store.state.selectedItemType = 'match';
                   }, 100);
              } else {
                 toast.error(`创建失败: ${result.error || '未知错误'}`);
              }
            };
            ```
        * 从 `useContextMenu.ts` 顶部**移除** `writeFile` 和 `serializeYaml` 的导入。
    2.  **处理 `handleConfirmDelete` (删除文件/文件夹部分):**
        * 在 `src/store/useEspansoStore.ts` 中添加新 Action:
            ```typescript
            // 在 useEspansoStore return 对象中添加
            deleteFileSystemNode: async (nodeId: string, nodePath: string, nodeType: 'file' | 'folder') => {
              console.log(`[Store] Action: deleteFileSystemNode ${nodeType}: ${nodePath}`);
              state.value.loading = true;
              try {
                // 1. 从文件系统删除
                if (nodeType === 'file') {
                  await platformService.deleteFile(nodePath);
                } else { // folder
                  await platformService.removeDirectory(nodePath); // 假设 platformService 有此方法
                }
                 console.log(`[Store] Deleted ${nodeType} from filesystem: ${nodePath}`);

                // 2. 重新加载配置以更新内存中的状态和树
                if (state.value.configRootDir) {
                  await loadConfig(state.value.configRootDir);
                  console.log('[Store] Config reloaded after file/folder deletion.');
                  return { success: true };
                } else {
                   console.error('[Store] Cannot reload config, configRootDir is null.');
                   // 注意：这里状态可能不一致，文件删了但内存没更新
                   throw new Error('文件/文件夹已删除，但无法刷新配置列表');
                }

              } catch (error: any) {
                console.error(`[Store] 删除 ${nodeType} 失败:`, error);
                state.value.error = `删除 ${nodeType} 失败: ${error.message || '未知错误'}`;
                 return { success: false, error: state.value.error };
              } finally {
                state.value.loading = false;
              }
            },
            ```
        * 修改 `src/hooks/useContextMenu.ts` 中的 `handleConfirmDelete`:
            ```typescript
            const handleConfirmDelete = async () => {
              if (!pendingDeleteId.value || !pendingDeleteType.value) return;

              const type = pendingDeleteType.value;
              const id = pendingDeleteId.value;
              const node = getCurrentNode(); // 获取当前节点用于获取 name 和 path
              const nodeName = node?.name;

              try {
                let result: { success: boolean, error?: string } | undefined;

                if (type === 'match' || type === 'group') {
                  // 删除匹配项或分组 (调用 Store Action)
                  await store.deleteItem(id, type); // 假设 deleteItem 返回 void 或处理自己的错误
                  result = { success: true }; // 假设成功
                  toast.success(`${type === 'match' ? '片段' : '分组'} "${nodeName}" 已删除`);

                } else if ((type === 'file' || type === 'folder') && node?.path) {
                   // 删除文件或文件夹 (调用新的 Store Action)
                   result = await store.deleteFileSystemNode(id, node.path, type);
                   if (result.success) {
                       toast.success(`${type === 'file' ? '文件' : '文件夹'} "${nodeName}" 已删除`);
                   } else {
                      throw new Error(result.error || '删除文件/文件夹失败');
                   }
                } else {
                   console.error(`无法删除类型为 ${type} 的项目，缺少路径信息。`);
                   toast.error(`无法删除项目: 缺少必要信息`);
                   result = { success: false, error: '缺少必要信息' };
                }

              } catch (error: any) {
                console.error(`删除 ${type} 失败:`, error);
                toast.error(`删除 "${nodeName || id}" 失败: ${error.message || error}`);
              } finally {
                // 重置状态
                pendingDeleteId.value = null;
                pendingDeleteType.value = null;
                confirmDialogVisible.value = false;
              }
            };
            ```
        * 确保 `useContextMenu.ts` 不再直接调用 `window.preloadApi.deleteFile` 或 `removeDirectory`。
    3.  **清理 `useContextMenu.ts`:**
        * 检查并移除文件顶部不再需要的导入（如 `writeFile`, `serializeYaml` 等）。
        * 检查 `handlePasteItem` 和 `handleCreateMatch`，确认它们只调用 Store 的 Actions (`moveTreeItem`, `addItem`)。

**第四阶段：重构 `useEspansoStore` (核心拆分)**

* **目的:** 将 Store 的巨大逻辑拆分到专门的 Service 中。
* **提示:** 这是最复杂的部分，可以分步进行，每一步完成后进行测试。
* **步骤:**
    1.  **创建 Service 文件:**
        * 在 `src/services/` 或新的 `src/services/espanso/` 目录下创建以下文件：
            * `EspansoLoadService.ts`
            * `EspansoSaveService.ts`
            * `EspansoDataProcessor.ts` (或修改 `espansoDataUtils.ts`)
            * `ConfigTreeManager.ts` (或修改 `configTreeUtils.ts`)
            * `EspansoManipulationService.ts`
    2.  **实现 `EspansoLoadService`:**
        * 创建 `EspansoLoadService` 类或对象。
        * 创建 `load(configDirOrPath: string): Promise<Partial<State>>` 方法。
        * **将 `useEspansoStore.ts` 中 `loadConfig` 函数的** **主体逻辑 (try 块内部)** **移动**到这个 `load` 方法中。
        * **替换**所有文件/YAML/路径操作为调用 `platformService` 的方法（例如 `platformService.readFile`, `platformService.parseYaml`, `platformService.joinPath`）。
        * **保持**对 `processMatch`, `processGroup` (来自 `espansoDataUtils`) 和 `createFileNode`, `addToTree` (来自 `configTreeUtils`) 的调用不变（暂时不移动这些工具函数）。
        * `load` 方法最后**返回**一个包含加载结果的对象，其结构应匹配 `State` 接口的部分字段，例如：`return { config: { matches: currentMatches, groups: currentGroups }, configTree, globalConfig, globalConfigPath, configPath, configRootDir, lastSavedState, hasUnsavedChanges: false };`。
        * 修改 `useEspansoStore.ts` 中的 `loadConfig` Action:
            ```typescript
            import { EspansoLoadService } from '@/services/EspansoLoadService'; // 导入

            const loadConfig = async (configDirOrPath: string): Promise<void> => {
              resetGuiOrderCounter(); // 这个可以保留在 Action 或移到 Service
              console.log('开始加载配置，路径:', configDirOrPath);
              state.value.loading = true;
              state.value.error = null;
              // 清理旧状态
              state.value.config = null;
              state.value.configTree = [];
              state.value.globalConfig = null;
              // ... 其他需要重置的状态 ...

              try {
                const loadService = new EspansoLoadService(); // 或直接导入对象方法
                const initialState = await loadService.load(configDirOrPath); // 调用 Service

                // 更新状态
                state.value.config = initialState.config;
                state.value.configTree = initialState.configTree;
                state.value.globalConfig = initialState.globalConfig;
                state.value.globalConfigPath = initialState.globalConfigPath;
                state.value.configPath = initialState.configPath;
                state.value.configRootDir = initialState.configRootDir;
                state.value.lastSavedState = initialState.lastSavedState;
                state.value.hasUnsavedChanges = initialState.hasUnsavedChanges;

                console.log('配置加载完成 via Service');
              } catch (error: any) {
                 console.error('加载配置失败:', error);
                 state.value.error = `加载配置失败: ${error.message}`;
                 // 可以在这里设置一个空的默认状态
                 if (!state.value.config) state.value.config = { matches: [], groups: [] };
              } finally {
                 state.value.loading = false;
              }
            };
            ```
    3.  **实现 `EspansoSaveService`:**
        * 创建 `EspansoSaveService` 类或对象。
        * 创建 `saveFile(filePath: string, configState: EspansoConfig | null, treeState: ConfigTreeNode[]): Promise<void>` 方法。
        * **将 `useEspansoStore.ts` 中 `saveItemToFile` 函数的** **主体逻辑 (try 块内部)** **移动**到这个 `saveFile` 方法中。
        * **替换**所有文件/YAML 操作为调用 `platformService` 的方法。
        * **保持**对 `cleanMatchForSaving`, `cleanNested` (来自 `espansoDataUtils` 或后续移到 `EspansoDataProcessor`) 和 `findFileNode` (来自 `configTreeUtils` 或后续移到 `ConfigTreeManager`) 的调用不变。
        * 修改 `useEspansoStore.ts` 中的 `saveItemToFile` Action:
            ```typescript
            import { EspansoSaveService } from '@/services/EspansoSaveService'; // 导入

            const saveItemToFile = async (itemToSave: Match | Group) => {
               const targetFilePath = itemToSave.filePath;
               if (!targetFilePath) { /* ...错误处理... */ throw new Error('Item missing filePath'); }
               console.log(`[Store] Action: saveItemToFile ${targetFilePath}`);
               state.value.autoSaveStatus = 'saving';

               try {
                 const saveService = new EspansoSaveService();
                 // 传入需要的数据给 Service
                 await saveService.saveFile(targetFilePath, state.value.config, state.value.configTree);
                 state.value.autoSaveStatus = 'saved';
                 // 可以考虑在保存成功后更新 lastSavedState 和 hasUnsavedChanges
                 // state.value.lastSavedState = JSON.stringify(...);
                 // state.value.hasUnsavedChanges = false;
                 console.log(`[Store] File saved successfully via Service: ${targetFilePath}`);
               } catch (error: any) {
                 console.error(`[Store] 保存文件失败 ${targetFilePath}:`, error);
                 state.value.error = `保存文件 ${targetFilePath} 失败: ${error.message || '未知错误'}`;
                 state.value.autoSaveStatus = 'error';
                 // 根据需要设置 hasUnsavedChanges
                 // state.value.hasUnsavedChanges = true;
                 throw error; // 重新抛出，让调用者知道失败了
               }
            };
            ```
    4.  **实现 `EspansoManipulationService` (处理复杂操作):**
        * 创建 `EspansoManipulationService` 类或对象。
        * 创建 `pasteItemCopy(itemDataToCopy: Match | Group, targetParentId: string | null, currentState: State): Promise<{newItemId: string | undefined, error?: string}>` 方法。**将 `useEspansoStore.ts` 中 `pasteItemCopy` 的逻辑移动到这里**。此方法内部需要调用 `generateId`, `findNodeById`, 可能需要调用 `addItem` (但 `addItem` 本身也需要重构，见下一步)。最后应返回新 ID 或错误。
        * 创建 `pasteItemCut(itemId: string, newParentId: string | null, currentState: State): Promise<{movedItemId: string | undefined, error?: string}>` 方法。**将 `useEspansoStore.ts` 中 `pasteItemCut` 的逻辑移动到这里**。这个方法会更复杂，需要查找、移除、更新路径、添加、保存多个文件。它会调用 `findItemById`, `findNodeById`, `findFileNode`, `removeFromTree`, `removeFromFlatListRecursive` (这些查找/移除逻辑也应移到相应的 Manager/Utils 或 Service 中)，并最终调用 `EspansoSaveService.saveFile`。
        * 创建 `moveTreeItemInternal(itemId: string, oldParentId: string | null, newParentId: string | null, oldIndex: number, newIndex: number, currentState: State): Promise<{success: boolean, error?: string}>` 方法。**将 `useEspansoStore.ts` 中 `moveTreeItem` 的非剪贴板部分逻辑移动到这里**。处理查找节点、数组操作、更新 `filePath`、调用 `EspansoSaveService.saveFile`。
        * **修改 Store Actions (`pasteItemCopy`, `pasteItemCut`, `moveTreeItem`):** 让这些 Actions 创建 `EspansoManipulationService` 实例，调用相应的方法（传入 `state.value`），并根据返回结果更新状态或显示错误。`moveTreeItem` Action 现在只处理顶层的剪贴板判断逻辑，然后调用 `pasteItemCopy` / `pasteItemCut` Action 或 `manipulationService.moveTreeItemInternal`。
    5.  **重构 Store CRUD Actions (`addItem`, `deleteItem`, `updateItem`):**
        * **`updateItem` / `updateConfigState`:** 这部分逻辑主要是状态更新，可以保留在 Store 中，但确保 `findAndUpdateInTree` 来自 `configTreeUtils` 或 `ConfigTreeManager`。
        * **`deleteItem`:** 移除文件保存逻辑。在移除内存状态后，调用 `saveItemToFile(triggerItem)` 或 `saveService.saveFile(filePath, ...)` 来处理文件保存。移除 `findAnyItemForFile` 的逻辑（这个查找逻辑可以移到 `EspansoSaveService` 内部判断是否需要写空文件）。
        * **`addItem`:** 移除文件保存逻辑。在添加到内存状态后，调用 `saveItemToFile(item)` 或 `saveService.saveFile(item.filePath, ...)`。
    6.  **(可选但推荐) 实现 `EspansoDataProcessor` 和 `ConfigTreeManager`:**
        * 将 `espansoDataUtils.ts` 中的 `processMatch`, `processGroup`, `cleanMatchForSaving`, `cleanNested` 等移到 `EspansoDataProcessor`。
        * 将 `configTreeUtils.ts` 中的 `createFileNode`, `createFolderNode`, `addToTree`, `findFileNode`, `findNodeById` 等移到 `ConfigTreeManager`。
        * 更新所有 Service 和 Store，使用这两个新的 Manager/Processor。
        * 清理 `espansoDataUtils.ts` 和 `configTreeUtils.ts`，可能只留下少量真正通用的函数（如 `generateId`）。
    7.  **测试:** 这是最关键的测试阶段。彻底测试加载、保存、添加、删除、更新、复制、剪切、粘贴、移动所有功能。

**第五阶段：最终审视和清理**

* **检查 `TreeNodeRegistry`:** 再次评估其必要性。如果保留，确保其逻辑清晰，没有做超出 UI 状态管理的事情。
* **检查 `ClipboardManager`:** 确认其功能单一且符合预期。
* **检查类型定义:** 确保 `src/types/` 目录下的类型定义清晰、无冗余，并在整个项目中一致使用。
* **代码审查:** 通读所有修改过的文件，检查代码风格、命名、注释是否一致和清晰。
* **移除未使用的代码:** 删除所有被注释掉的旧代码、未使用的导入、变量或函数。

---

这个计划非常详细，每一步都构建在前一步的基础上。请务必按顺序执行，并在每个阶段后进行充分的测试。祝重构顺利！