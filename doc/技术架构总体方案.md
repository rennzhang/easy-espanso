好的，顶级架构师为你准备了一份更完整、更详细的技术方案文档。这份文档旨在为你的实习生提供清晰的指导，让他能够系统地完成 ESPANSO 配置管理工具的开发，同时最大程度地规避业务逻辑组织上的障碍。

---

**文档标题：ESPANSO 配置管理工具 uTools 插件技术方案**

**版本：1.0**

**日期：2025年4月26日**

**作者：[你的名字/顶级架构师]**

**1. 引言**

本文档旨在详细阐述基于 uTools 平台开发 ESPANSO 配置管理工具的技术方案。项目的核心目标是提供一个用户友好的图形化界面，以替代 ESPANSO 传统的 YAML 文件编辑方式，从而降低用户学习曲线，提高配置效率。考虑到项目开发人员在业务逻辑组织方面存在的挑战，本方案着重于构建清晰的分层架构，严格分离用户界面、业务逻辑和底层服务，确保开发人员能够专注于其擅长的纯粹编码任务。

**2. 总体架构设计**

本项目的架构遵循经典的三层模式，并根据 uTools 插件的特性进行调整：

* **展现层 (Presentation Layer):** 基于 React 和 Shadcn UI 构建用户界面。负责接收用户输入、展示数据和 UI 状态。这一层将保持“纯粹”，不包含业务逻辑，只负责调用业务逻辑层提供的方法和根据业务逻辑层提供的状态进行渲染。
* **应用逻辑层 (Application Logic Layer):** 使用 Zustand 管理全局应用状态和业务逻辑。负责协调展现层和底层服务层，处理用户操作引起的业务流程，如数据的增删改查、排序、过滤、验证等。复杂的状态变化和业务规则将集中在此层处理。
* **服务层 (Service Layer):** 提供与外部系统或复杂功能交互的能力。
    * **平台服务 (uTools Preload Script):** 利用 uTools 的 Node.js 能力，提供文件系统访问（读写 ESPANSO 配置文件）和系统对话框（选择目录）等与操作系统交互的功能。
    * **ESPANSO 特有服务 (Utils Module):** 包含处理 ESPANSO 配置文件格式（YAML 解析/序列化）和 ESPANSO 特有功能（内置变量、功能函数、规则预览）的纯函数工具集。

**架构示意图：**

```mermaid
graph TD
    A[用户] --> B[UI Layer (React/Shadcn UI)]
    B --> C[Application Logic Layer (Zustand Store)]
    C --> D[Service Layer]
    D --> D1[Platform Service (Preload Script)]
    D --> D2[Espanso Specific Service (Utils)]
    D1 --> E[文件系统 / 操作系统]
    D2 --> F[Espanso 配置文件格式 / 功能]
    C --> B
    D --> C
```

**职责划分：**

* **UI 组件：** 负责渲染；通过 `onClick`, `onChange` 等事件调用 Zustand Actions；通过 `useStore()` Hook 获取状态进行展示。
* **Zustand Store：** 负责存储应用状态；定义 Actions 来修改状态；Actions 中可以调用 Service Layer 的方法完成业务逻辑。
* **Preload Script：** 负责执行 Node.js API 调用；不包含业务逻辑或 UI 状态。
* **Utils Module：** 负责纯粹的数据转换和计算；不包含业务逻辑或 UI 状态。

**3. 技术栈选型**

* **前端框架:** React 18+ (已提供)
* **构建工具:** Vite (已提供)
* **UI 组件库:** Shadcn UI (基于 Radix UI & Tailwind CSS) - 提供简洁、精致、可定制的组件。
* **样式:** Tailwind CSS - 与 Shadcn UI 集成，提供原子化 CSS 类，方便样式定制。
* **状态管理:** Zustand - 小巧、快速、易于学习，适合管理跨组件的复杂状态。
* **表单管理:** React Hook Form - 高性能的表单管理库，简化表单状态、验证和提交逻辑。与 Zustand 和 Shadcn UI 集成友好。
* **拖拽功能:** React DnD (React-dnd) - 用于实现分组和规则的拖拽排序。
* **YAML 处理:** `js-yaml` - 用于解析和序列化 YAML 配置文件。在 Preload Script 和 Renderer Process 中都需要使用。
* **唯一 ID 生成:** `uuid` (推荐) - 用于为分组和规则生成唯一的标识符，方便状态管理和查找。
* **平台 API:** uTools API - 用于获取应用进入参数、显示通知、打开文件对话框等。
* **文件系统 API:** Node.js `fs` 和 `path` 模块 - 通过 Preload Script 访问。

**4. 数据模型设计 (TypeScript)**

以下是应用内部使用的数据模型定义，用于在 Zustand store 中存储 ESPANSO 配置数据。这与实际的 ESPANSO YAML 结构会有映射关系，但在应用内部更便于操作。

```typescript
// src/types/espanzo-config.ts

// 定义所有项目（规则或分组）共享的基础属性
export interface BaseItem {
  id: string; // 唯一的标识符，用于在应用内部识别和管理
  type: 'rule' | 'group'; // 项目类型
  label?: string; // 用户友好的描述或名称
  createdAt: number; // 创建时间戳，用于排序
  updatedAt: number; // 最后修改时间戳，用于排序和优先级判断
  // 内部使用属性，方便UI层展示，不一定直接映射到Espanso配置
  isExpanded?: boolean; // 用于分组折叠状态
}

// 定义规则的属性
export interface EspansoRule extends BaseItem {
  type: 'rule';
  trigger: string; // 触发词，如 ":date"
  // 在应用内部，我们将Espanso的'replace'字段拆解为contentType和content
  contentType: 'plain' | 'rich' | 'html' | 'script' | 'image' | 'form' | 'clipboard' | 'shell' | 'key'; // Espanso支持的内容类型
  content: string | any; // 实际内容，根据contentType可以是字符串、脚本代码、base64图片等，form等复杂类型可能需要更详细的结构
  caseSensitive?: boolean; // 是否区分大小写
  word?: boolean; // 是否整词匹配
  apps?: string[]; // 生效的应用列表，空数组或undefined表示所有应用
  priority?: number; // 规则优先级 (数字越大优先级越高)
  hotkey?: string; // 快捷键触发 (如果Espanso支持)
  tags?: string[]; // 标签数组
  // Espanso还支持其他一些高级属性，如vars, form, key, shell等，需要根据文档补充到content或独立字段中
  // 例如，如果contentType是'form'，content可能是一个表示表单结构的JSON对象
}

// 定义分组的属性
export interface EspansoGroup extends BaseItem {
  type: 'group';
  name: string; // 分组名称，用户可读
  prefix?: string; // 分组公共前缀，应用于组内所有规则 (如果Espanso支持组级前缀)
  children: Array<EspansoRule | EspansoGroup>; // 嵌套的规则和分组
  // 内部使用属性，方便UI层展示，不一定直接映射到Espanso配置
  parentId: string | 'root'; // 父分组的ID，'root'表示顶层
}

// 定义整个ESPANSO配置的结构
export interface EspansoConfig {
  // Espanso配置的顶层结构可能是一个包含rules和includes的数组
  // 在我们的应用内部，我们将其映射为一个虚拟的根分组，方便树状结构管理
  root: EspansoGroup; // 虚拟的根分组，其children包含顶层所有规则和分组
  // 其他全局设置，如backend, listen_clipboard等，如果需要管理，也可以添加到这里
  globalSettings?: {
      backend?: string;
      listen_clipboard?: boolean;
      // ... other global settings
  };
}

// 定义应用界面的状态
export interface UIState {
  selectedItemId: string | null; // 当前在右侧编辑面板选中的项目ID
  isEditing: boolean; // 是否正在编辑状态 (可以用于控制按钮禁用状态)
  leftMenuCollapsed: boolean; // 左侧菜单是否收起
  middlePaneFilterTags: string[]; // 中间面板按标签过滤的状态
  // ... 其他UI状态
}
```

**5. 应用逻辑层 (Zustand Store)**

Zustand store 将是应用的核心状态容器和业务逻辑处理中心。

```typescript
// src/store/useEspansoStore.ts
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer'; // 使用immer简化不可变状态更新
import { EspansoConfig, EspansoRule, EspansoGroup, BaseItem, UIState } from '../types/espanzo-config';
import { readFile, writeFile, showOpenDialog } from '../services/fileService'; // 从 preload 导入的服务
import { parseYaml, serializeYaml, generateId, findItemById, removeItemById, insertItemAtIndex, walkTree } from '../utils/espanzo-utils'; // 从 utils 导入的工具函数
import { produce } from 'immer'; // immer 库

interface EspansoState {
  config: EspansoConfig | null;
  ui: UIState;
  loading: boolean;
  error: string | null;
  configFilePath: string | null; // 存储当前配置文件的路径

  // Actions
  loadConfig: (filePath?: string) => Promise<void>;
  saveConfig: () => Promise<void>;
  selectItem: (itemId: string | null) => void;
  setLeftMenuCollapsed: (collapsed: boolean) => void;
  // ... 其他UI相关的Actions

  addItem: (parentGroupId: string | 'root', type: 'rule' | 'group', initialData?: Partial<EspansoRule | EspansoGroup>) => void;
  updateItem: (itemId: string, updates: Partial<EspansoRule | EspansoGroup>) => void;
  deleteItem: (itemId: string) => void;
  moveItem: (draggedItemId: string, targetItemId: string | 'root', position: 'before' | 'after' | 'into') => void; // 更细致的拖拽移动Action
  // ... 其他配置管理Actions (导入/导出/复制/粘贴等)

  // Selector (derived state) - 用于从state计算派生数据，避免在组件中重复计算
  getSelectedItem: () => BaseItem | EspansoRule | EspansoGroup | null;
  getAllTags: () => string[]; // 获取所有规则中使用的标签
  // ... 其他Selectors
}

export const useEspansoStore = create<EspansoState>()(
    immer((set, get) => ({
      // Initial State
      config: null,
      ui: {
        selectedItemId: null,
        isEditing: false, // Might be managed by React Hook Form internally, but can exist here too
        leftMenuCollapsed: false,
        middlePaneFilterTags: [],
      },
      loading: false,
      error: null,
      configFilePath: null,

      // Actions Implementation
      loadConfig: async (filePath?: string) => {
        set(state => {
           state.loading = true;
           state.error = null;
           if(filePath) state.configFilePath = filePath; // Update path if provided
        });

        const currentPath = get().configFilePath;

        if (!currentPath) {
             // If no path is set, prompt user to select directory
            const selectedDirs = await showOpenDialog({
                title: '请选择 ESPANSO 配置文件夹 (包含 default.yml 的目录)',
                properties: ['openDirectory']
            });

            if (!selectedDirs || selectedDirs.length === 0) {
                 set(state => {
                     state.loading = false;
                     state.error = '未选择有效的 ESPANSO 配置文件夹。';
                 });
                 return;
            }
             // Construct the expected config file path (adjust based on OS and common Espanso install paths)
             const guessedFilePath = `${selectedDirs[0]}/${process.platform === 'win32' ? 'config\\default.yml' : 'config/default.yml'}`;
             set(state => { state.configFilePath = guessedFilePath; });
             // Retry loading with the guessed path
             get().loadConfig(); // Recursive call with path
             return; // Stop current execution
        }


        try {
          const content = await readFile(currentPath);
          const parsedData = parseYaml(content);

          // TODO: Validate parsedData structure against Espanso's expected format carefully!
          // TODO: Convert Espanso's format (e.g., matches array) to our internal root group structure
          // This is a critical conversion step. Need a robust `convertToInternalFormat` function.
          const internalConfig = convertToInternalFormat(parsedData);

          // Add internal IDs and timestamps if they don't exist
          const configWithIdsAndTimestamps = addIdsAndTimestamps(internalConfig);

          set(state => {
              state.config = configWithIdsAndTimestamps;
              state.loading = false;
              state.error = null;
          });

        } catch (err: any) {
          console.error("Failed to load or parse config:", err);
          set(state => {
             state.config = null; // Clear potentially invalid config
             state.loading = false;
             state.error = `加载或解析配置文件失败: ${err.message}`;
             state.configFilePath = null; // Clear path so next load prompts again
          });
           // Show error notification
           window.utools.showNotification('加载配置文件失败，请检查文件或重新选择目录。');
        }
      },

      saveConfig: async () => {
        const { config, configFilePath } = get();
        if (!config || !configFilePath) {
          set(state => { state.error = '无法保存：配置或文件路径无效。'; });
          return;
        }
        set(state => { state.loading = true; state.error = null; });
        try {
          // TODO: Convert our internal structure back to Espanso's expected YAML format
          const espansoFormatData = convertToEspansoFormat(config);
          const yamlContent = serializeYaml(espansoFormatData);
          await writeFile(configFilePath, yamlContent);
          set(state => { state.loading = false; });
          window.utools.showNotification('配置文件保存成功！');
        } catch (err: any) {
           console.error("Failed to save config:", err);
          set(state => {
             state.loading = false;
             state.error = `保存文件失败: ${err.message}`;
          });
          window.utools.showNotification('文件保存出错了！');
        }
      },

      selectItem: (itemId: string | null) => {
         set(state => {
             state.ui.selectedItemId = itemId;
             // When selecting a new item, maybe reset isEditing state
             // state.ui.isEditing = false;
         });
      },

      setLeftMenuCollapsed: (collapsed: boolean) => {
          set(state => { state.ui.leftMenuCollapsed = collapsed; });
      },
      // ... other UI state actions

      addItem: (parentGroupId: string | 'root', type: 'rule' | 'group', initialData?: Partial<EspansoRule | EspansoGroup>) => {
          set(state => {
              if (!state.config) return;

              const now = Date.now();
              const newItem: BaseItem = {
                  id: generateId(),
                  type,
                  createdAt: now,
                  updatedAt: now,
                  label: (initialData as any)?.label || (type === 'rule' ? '新规则' : '新分组'), // Default label
                  ...initialData as any, // Spread initial data
                  ...(type === 'group' ? { children: [] as (EspansoRule | EspansoGroup)[], parentId: parentGroupId } : {}), // Group specific props
                  ...(type === 'rule' ? { trigger: (initialData as any)?.trigger || '', content: (initialData as any)?.content || '', contentType: (initialData as any)?.contentType || 'plain' } : {}), // Rule specific props
              };

              // Find the parent group and add the new item
              walkTree(state.config.root, (item, parent) => {
                  if ((parentGroupId === 'root' && item.id === state.config?.root.id) || (item.type === 'group' && item.id === parentGroupId)) {
                       item.children.push(newItem as any);
                       // Select the newly added item
                       state.ui.selectedItemId = newItem.id;
                       return true; // Stop walking the tree
                  }
                   return false; // Continue walking
              });
          });
      },

      updateItem: (itemId: string, updates: Partial<EspansoRule | EspansoGroup>) => {
          set(state => {
              if (!state.config) return;

              // Find the item by ID and update its properties
              walkTree(state.config.root, (item, parent) => {
                  if (item.id === itemId) {
                      // Apply updates, ensuring type safety if needed
                      Object.assign(item, updates);
                      item.updatedAt = Date.now(); // Update timestamp on modification
                      // If the updated item is the selected item, update selectedItem in UI state (optional, often implicit)
                      // if (state.ui.selectedItemId === itemId) { ... }
                      return true; // Stop walking
                  }
                   return false; // Continue walking
              });
          });
      },

      deleteItem: (itemId: string) => {
          set(state => {
              if (!state.config) return;

              // Remove the item by ID
               const originalRoot = state.config.root;
               const [updatedRoot, removedItemParentId] = removeItemById(originalRoot, itemId); // need to implement removeItemById in utils

               if (updatedRoot) {
                    state.config.root = updatedRoot;
                    // If the deleted item was selected, deselect it
                    if (state.ui.selectedItemId === itemId) {
                        state.ui.selectedItemId = null;
                    }
               } else {
                   console.error("Item not found for deletion:", itemId);
               }
          });
      },

      moveItem: (draggedItemId: string, targetItemId: string | 'root', position: 'before' | 'after' | 'into') => {
           set(state => {
               if (!state.config) return;

               // 1. Find the dragged item and remove it from its original position
               const originalRoot = state.config.root;
               let draggedItem: EspansoRule | EspansoGroup | null = null;
               let sourceParentId: string | 'root' | null = null;

               const tempRootAfterRemoval = removeItemById(originalRoot, draggedItemId, (item, parentId) => {
                   if (item.id === draggedItemId) {
                       draggedItem = item;
                       sourceParentId = parentId;
                   }
               });

               if (!draggedItem || !tempRootAfterRemoval) {
                   console.error("Dragged item not found:", draggedItemId);
                   return;
               }

               // 2. Insert the dragged item into the target position
               const updatedRoot = insertItemAtIndex(tempRootAfterRemoval[0], targetItemId, draggedItem, position); // need to implement insertItemAtIndex in utils

               if (updatedRoot) {
                   state.config.root = updatedRoot;
                   // Update modified timestamp of the moved item and its new parent/ancestors? (Depends on Espanso behavior)
                   // draggedItem.updatedAt = Date.now(); // Or only on save?
               } else {
                    console.error("Failed to insert item:", draggedItemId, "into", targetItemId, "at", position);
               }
           });
      },

      // Selector Implementations
      getSelectedItem: () => {
           const { config, ui } = get();
           if (!config || !ui.selectedItemId) return null;
           return findItemById(config.root.children, ui.selectedItemId); // need to implement findItemById in utils
      },

      getAllTags: () => {
           const { config } = get();
           if (!config) return [];
           const tags = new Set<string>();
           walkTree(config.root, (item) => {
               if (item.type === 'rule' && item.tags) {
                   item.tags.forEach(tag => tags.add(tag));
               }
                return false; // Continue walking
           });
           return Array.from(tags);
      }
      // ... Other selector implementations
    }))
);
```

**需要实习生实现的 `espanzo-utils.ts` 关键工具函数：**

```typescript
// src/utils/espanzo-utils.ts
import yaml from 'js-yaml';
import { EspansoConfig, EspansoRule, EspansoGroup, BaseItem } from '../types/espanzo-config';
import { v4 as uuidv4 } from 'uuid'; // Using uuid library

// 生成唯一ID
export function generateId(): string {
    return uuidv4();
}

// 递归遍历树结构
export function walkTree(item: EspansoGroup | EspansoRule, callback: (item: EspansoRule | EspansoGroup, parent: EspansoGroup | null) => boolean | void, parent: EspansoGroup | null = null): boolean {
    if (callback(item, parent)) {
        return true; // Stop traversal if callback returns true
    }
    if (item.type === 'group' && item.children) {
        for (const child of item.children) {
            if (walkTree(child, callback, item)) {
                 return true; // Stop if child traversal stops
            }
        }
    }
    return false; // Continue traversal
}


// 查找指定ID的项目
export function findItemById(items: Array<EspansoRule | EspansoGroup>, id: string): EspansoRule | EspansoGroup | null {
    for (const item of items) {
        if (item.id === id) {
            return item;
        }
        if (item.type === 'group' && item.children) {
            const found = findItemById(item.children, id);
            if (found) return found;
        }
    }
    return null;
}

// 从树结构中移除指定ID的项目，并返回移除后的根节点和移除项的父ID
export function removeItemById(root: EspansoGroup, id: string, onRemove?: (item: EspansoRule | EspansoGroup, parentId: string | 'root') => void): [EspansoGroup | null, string | 'root' | null] {
    let removedParentId: string | 'root' | null = null;
    let itemRemoved = false;

    const filterChildren = (items: Array<EspansoRule | EspansoGroup>, parentId: string | 'root'): Array<EspansoRule | EspansoGroup> => {
        return items.filter(item => {
            if (item.id === id) {
                itemRemoved = true;
                removedParentId = parentId;
                 if(onRemove) onRemove(item, parentId);
                return false; // Remove this item
            }
            if (item.type === 'group') {
                item.children = filterChildren(item.children, item.id);
            }
            return true; // Keep other items
        });
    };

    const updatedRootChildren = filterChildren(root.children, root.id); // Assume root.id is the identifier for the virtual root
     if (itemRemoved) {
         return [{ ...root, children: updatedRootChildren }, removedParentId];
     }
    return [null, null]; // Item not found
}


// 将项目插入到指定位置 (用于拖拽)
export function insertItemAtIndex(
    root: EspansoGroup,
    targetItemId: string | 'root',
    itemToInsert: EspansoRule | EspansoGroup,
    position: 'before' | 'after' | 'into' // 'into' means add as a child of targetGroup
): EspansoGroup | null {
    let inserted = false;

    const insert = (items: Array<EspansoRule | EspansoGroup>, parentId: string | 'root'): Array<EspansoRule | EspansoGroup> => {
        const newItems: Array<EspansoRule | EspansoGroup> = [];

        for (const item of items) {
             if (item.id === targetItemId) {
                 if (position === 'before') {
                     newItems.push(itemToInsert);
                     newItems.push(item);
                     inserted = true;
                 } else if (position === 'after') {
                      newItems.push(item);
                      newItems.push(itemToInsert);
                      inserted = true;
                 } else if (position === 'into' && item.type === 'group') {
                      // Insert as the first child if 'into' a group
                      const children = [itemToInsert, ...item.children];
                      newItems.push({ ...item, children });
                      inserted = true;
                 } else {
                     // Cannot drop 'into' a rule
                     newItems.push(item);
                 }
             } else {
                newItems.push(item);
                 if (item.type === 'group') {
                    item.children = insert(item.children, item.id); // Recurse
                 }
             }
             // If inserting into the root, targetItemId is 'root'
             if (targetItemId === 'root' && parentId === root.id && !inserted) {
                 if (position === 'before' || position === 'after') {
                     // Handle insertion at specific index in the root array - more complex
                     // For simplicity in this model, assume 'before'/'after' on root means before/after the first/last item or based on targetItemId within root.children
                     // A more robust implementation would involve finding the index of targetItemId in root.children and splicing.
                     // For now, let's simplify: If targetItemId is 'root', and position is 'into', maybe add to end of root.children? Or 'before' first, 'after' last?
                     // Let's refine the `moveItem` logic in the store or here to be more precise with index.
                     // A common DnD pattern is to provide the target item ID and whether to place before/after it, or inside it (for groups).
                      // If targetItemId is 'root' and position is 'into', add to the end of root's children
                     if (targetItemId === 'root' && position === 'into') {
                          // This case should ideally be handled by targeting the root group itself with position 'into'
                          // Or the UI DnD logic needs to signal dropping onto the "list area" of the root.
                           // For now, let's assume 'into' targetting the root implies adding to the end of root.children if root is the target.
                           // This might be too simplified for precise ordering at the root level.
                           // A better approach for root level drop would be to identify the index based on where the drop occurred visually.
                     }

                 }
             }
        }
         // If dropping 'into' a group that was *not* the target, need to handle recursion
        return newItems;
    };

     // Special case for dropping directly into the root (if targetItemId is 'root' and position is 'into')
     if (targetItemId === root.id && position === 'into') {
          const children = [...root.children, itemToInsert]; // Add to the end of root's children
          return { ...root, children };
     }


    const updatedRootChildren = insert(root.children, root.id);

     if(inserted) {
          return { ...root, children: updatedRootChildren };
     }

    // If item was not inserted by targetItemId match, it might be dropped at the root level
    // Need to handle dropping onto the empty space of the root or at a specific index at root level.
    // This requires more context from the DnD event (e.g., the index where dropped).
    // Let's assume the MiddlePane's DnD logic provides a precise index for root level drops.
    // For now, if targetItemId is 'root' and position is not 'into', we need a different insertion logic.
    // This simplified `insertItemAtIndex` primarily handles insertion relative to another item or *into* a group.
    // A more robust drag/drop implementation would require passing target parent ID and target index.

    console.error("Item not inserted. Need to handle root level drop with precise index.");
    return null; // Indicate insertion failed by this function
}


// TODO: 将 Espanso 的 YAML 格式转换为我们的内部数据模型
// 这是一个关键且复杂的步骤，需要仔细对照 Espanso 文档实现
// 需要处理 matches 数组、rule 对象、include 指令、不同 replace 类型的结构
export function convertToInternalFormat(espansoData: any): EspansoConfig {
    const rootGroup: EspansoGroup = {
        id: 'root', // 虚拟根ID
        type: 'group',
        name: '所有配置', // 或从 Espanso 全局设置中获取名称
        createdAt: Date.now(), // 或使用文件修改时间
        updatedAt: Date.now(), // 或使用文件修改时间
        children: [],
        parentId: 'root', // 根节点的父ID是自身或者一个特殊标记
        isExpanded: true, // 默认展开根节点
    };

    // 假设 espansoData 的顶层是 { matches: [...] }
    if (espansoData && Array.isArray(espansoData.matches)) {
        espansoData.matches.forEach((itemData: any) => {
            // TODO: 根据 itemData 的结构判断是规则还是分组或 include
            if (itemData.trigger && itemData.replace !== undefined) { // Likely a rule
                 const rule: EspansoRule = {
                     id: generateId(), // 生成内部ID
                     type: 'rule',
                     createdAt: Date.now(), // Placeholder, ideally from file metadata or Espanso config
                     updatedAt: Date.now(), // Placeholder
                     trigger: itemData.trigger,
                     label: itemData.label || '', // Use label if exists
                     // TODO: 将 itemData.replace 的结构解析为 contentType 和 content
                     contentType: 'plain', // Placeholder
                     content: itemData.replace, // Placeholder

                     caseSensitive: itemData.case_sensitive,
                     word: itemData.word,
                     apps: itemData.apps,
                     priority: itemData.priority,
                     hotkey: itemData.key, // Map Espanso 'key' to hotkey
                     tags: itemData.tags,
                      // Map other Espanso rule properties
                 };
                 rootGroup.children.push(rule);
            } else if (itemData.name && Array.isArray(itemData.matches)) { // Likely a group (based on nested matches?)
                 // Espanso's grouping might be represented differently. Need to confirm.
                 // This is a simplified assumption for nested structure.
                  // If Espanso groups are just comments or includes, this needs adjustment.
                 // Let's assume for now a structure like { name: 'GroupName', matches: [...] } represents a group
                 const group: EspansoGroup = {
                      id: generateId(),
                      type: 'group',
                      name: itemData.name,
                      createdAt: Date.now(),
                      updatedAt: Date.now(),
                      children: [], // Recursively process children? Or shallow initially?
                      parentId: rootGroup.id,
                       prefix: itemData.prefix, // If group has prefix
                       isExpanded: true,
                 };
                 // Recursively convert children if needed
                 if(itemData.matches) {
                      itemData.matches.forEach((childData: any) => {
                           // TODO: Convert childData and add to group.children
                           // This needs a recursive call or helper
                            if (childData.trigger) {
                                const childRule: EspansoRule = {
                                    id: generateId(),
                                    type: 'rule',
                                     createdAt: Date.now(),
                                    updatedAt: Date.now(),
                                    trigger: childData.trigger,
                                    label: childData.label || '',
                                     contentType: 'plain', // Placeholder
                                     content: childData.replace, // Placeholder
                                     // ... map other rule properties
                                };
                                group.children.push(childRule);
                            }
                            // Handle nested groups if Espanso supports it this way
                      });
                 }
                 rootGroup.children.push(group);

            }
             // TODO: Handle '!include' directives - maybe represent as a special item type?
        });
    } else {
         // Handle other potential root structures or throw error if unexpected
          console.warn("Espanso config root structure not as expected (missing matches array).", espansoData);
          // Attempt to parse top-level items directly if not in 'matches'
          // This is a fallback and might not cover all cases.
           if (espansoData.trigger) { // If it looks like a single rule at the top level
               const rule: EspansoRule = {
                     id: generateId(),
                     type: 'rule',
                     createdAt: Date.now(),
                     updatedAt: Date.now(),
                     trigger: espansoData.trigger,
                     label: espansoData.label || '',
                      contentType: 'plain', // Placeholder
                     content: espansoData.replace, // Placeholder
                      // ... map other rule properties
                 };
                 rootGroup.children.push(rule);
           }
    }


     // TODO: After initial parsing, add parentId to all items for easier traversal
     walkTree(rootGroup, (item, parent) => {
         if (item.id !== rootGroup.id && parent) {
              (item as any).parentId = parent.id;
         } else if (item.id === rootGroup.id) {
              (item as any).parentId = 'root'; // Mark root parent
         }
          return false;
     });


    return { root: rootGroup };
}


// TODO: 将内部数据模型转换回 Espanso 的 YAML 格式
// 这是一个关键且复杂的步骤，需要仔细对照 Espanso 文档实现
// 需要处理 matches 数组、rule 对象、include 指令、不同 content 类型的结构
export function convertToEspansoFormat(internalConfig: EspansoConfig): any {
    const espansoMatches: any[] = [];

    // Recursively convert internal items to Espanso format
    const convertItems = (items: Array<EspansoRule | EspansoGroup>): any[] => {
        const espansoItems: any[] = [];
        items.forEach(item => {
            if (item.type === 'rule') {
                const espansoRule: any = {
                    trigger: item.trigger,
                    // TODO: 将 item.contentType 和 item.content 转换回 Espanso 的 replace 结构
                    // This is complex, especially for form, clipboard, shell, key types.
                    // Need to handle serialization based on contentType.
                    replace: item.content, // Simple placeholder mapping
                     // Map other rule properties back to Espanso names
                    ...(item.label && { label: item.label }),
                    ...(item.caseSensitive !== undefined && { case_sensitive: item.caseSensitive }),
                    ...(item.word !== undefined && { word: item.word }),
                    ...(item.apps && item.apps.length > 0 && { apps: item.apps }),
                    ...(item.priority !== undefined && item.priority !== 0 && { priority: item.priority }), // Only include if not default
                    ...(item.hotkey && { key: item.hotkey }), // Map hotkey back to Espanso 'key'
                    ...(item.tags && item.tags.length > 0 && { tags: item.tags }),
                     // Include other Espanso specific rule properties
                };
                espansoItems.push(espansoRule);
            } else if (item.type === 'group') {
                 // TODO: Convert group structure back to Espanso format
                 // Assuming Espanso groups are represented by nested matches with a name/prefix
                 const espansoGroup: any = {
                      name: item.name,
                      ...(item.prefix && { prefix: item.prefix }),
                      matches: convertItems(item.children), // Recursively convert children
                 };
                 espansoItems.push(espansoGroup);
            }
             // TODO: Handle '!include' items if we support representing them internally
        });
        return espansoItems;
    };

    // Start conversion from the root group's children
    espansoMatches.push(...convertItems(internalConfig.root.children));

     // Include global settings if any
     const espansoData: any = {
         matches: espansoMatches,
         // ... add global settings
     };
     if (internalConfig.globalSettings) {
         Object.assign(espansoData, internalConfig.globalSettings);
     }


    return espansoData;
}


// TODO: 获取 Espanso 支持的内置变量和功能列表
// 可以硬编码这个列表，或者尝试从 Espanso 的某个地方读取（如果可行）
export function getAvailableVariables(): string[] {
    return ['date', 'clipboard', 'time', 'os', 'hostname', 'username', 'email', 'path', 'selection', 'form', 'key', 'shell']; // Example list
}

// TODO: 获取 Espanso 支持的脚本类型或函数列表
// export function getAvailableScriptTypes(): string[] { ... }


// TODO: 实现规则预览逻辑
// 这可能需要模拟 Espanso 的展开行为，处理变量、脚本等，可能会比较复杂
export function generatePreview(rule: EspansoRule): string {
    let previewText = rule.content;
    // TODO: Implement logic to replace variables like {{date}}, {{clipboard}} etc. with sample data
    // TODO: Implement logic to simulate script execution for script type
    // TODO: Handle rich text/html rendering if possible in a limited preview area
    // TODO: For image type, display a placeholder or thumbnail
    return `Preview of "${rule.trigger}":\n---\n${previewText}\n--- (Note: Preview is a simulation)`;
}

// Helper to add IDs and timestamps recursively if missing during parsing
export function addIdsAndTimestamps(item: any): any {
    if (typeof item !== 'object' || item === null) {
        return item;
    }

    if (Array.isArray(item)) {
        return item.map(addIdsAndTimestamps);
    }

    const now = Date.now();
    const newItem = {
        ...item,
        id: item.id || generateId(),
        createdAt: item.createdAt || now,
        updatedAt: item.updatedAt || now,
        // Ensure type is set for internal consistency, infer if possible
        type: item.type || (item.trigger ? 'rule' : (item.name && item.children !== undefined ? 'group' : undefined)), // Infer type based on properties
        // Add parentId if not present (easier after initial structure is built)
    };

    // Recursively process children if it's a group or similar structure
    if (newItem.type === 'group' && newItem.children) {
        newItem.children = addIdsAndTimestamps(newItem.children);
    }
     // If the parsed data is the top-level matches array from Espanso, wrap it in a root group
    if (Array.isArray(newItem.matches)) {
        const rootGroup: EspansoGroup = {
            id: 'root',
            type: 'group',
            name: '所有配置',
            createdAt: newItem.createdAt,
            updatedAt: newItem.updatedAt,
            children: addIdsAndTimestamps(newItem.matches), // Process the items in matches array
            parentId: 'root',
             isExpanded: true,
        };
         // Add parentId for top-level children
         rootGroup.children.forEach(child => {
             if (child.type !== 'group') (child as any).parentId = rootGroup.id;
         });

        return { root: rootGroup }; // Return wrapped structure
    }


    // Ensure all internal group items have a children array
    if (newItem.type === 'group' && !newItem.children) {
         newItem.children = [];
    }


    return newItem;
}

// Helper to recursively set parentId after the tree is built
export function setParentIds(item: EspansoGroup, parentId: string | 'root' = 'root') {
    item.parentId = parentId;
    if (item.children) {
        item.children.forEach(child => {
            if (child.type === 'group') {
                setParentIds(child, item.id);
            } else {
                 (child as any).parentId = item.id; // Add parentId to rules as well
            }
        });
    }
}

```
**注意:** `convertToInternalFormat` 和 `convertToEspansoFormat` 的实现是理解和映射 Espanso YAML 结构的**核心**和**最复杂**的部分。需要仔细对照 Espanso 的官方文档，确保不同 `replace` 类型的规则（如 `form`, `clipboard`, `shell`, `key`）和分组结构能够准确地在两种格式之间转换，且不丢失任何信息。如果 Espanso 的分组是通过注释或其他非标准 YAML 方式表示的，这部分逻辑会更复杂。我在这里提供的实现是基于一种可能的简化结构假设，实际开发中需要根据真实的 Espanso YAML 结构进行调整。

**6. 组件设计 (续 - 详细的编辑表单)**

我们将详细设计 `GroupEditForm` 和 `RuleEditForm` 组件。它们将使用 React Hook Form 来管理本地表单状态和验证，并通过 props 接收 Zustand store 的 save/cancel/delete 回调。

**6.1. `GroupEditForm.jsx` 详细设计**

* **Props:**
    * `group: EspansoGroup` - 当前要编辑的分组对象。
    * `onSave: (itemId: string, values: Partial<EspansoGroup>) => void` - 保存按钮点击时调用的回调。
    * `onCancel: () => void` - 取消按钮点击时调用的回调。
    * `onDelete: (itemId: string) => void` - 删除按钮点击时调用的回调。
* **内部状态:** 由 React Hook Form 管理表单字段的值、验证状态等。
* **表单字段 (使用 Shadcn UI Form 和 Input/Textarea):**
    * **分组名称 (name):** Text Input, 必填。
    * **描述 (label):** Textarea, 可选。
    * **公共前缀 (prefix):** Text Input, 可选。
    * **其他分组属性:** 如果 Espanso 分组支持其他配置（如图标、颜色等），在此添加相应字段。
* **验证:** 使用 Zod 定义 `groupFormSchema` 进行验证。
* **生命周期:**
    * `useEffect` 监听 `group` 变化，当 `group` 改变时，使用 `form.reset(group)` 更新表单默认值，确保显示的是当前选中的分组数据。
* **事件处理:**
    * 表单提交 (`form.handleSubmit(onSubmit)`): 调用 `onSave` 回调，传递分组 ID 和表单值。
    * 取消按钮点击: 调用 `onCancel` 回调。
    * 删除按钮点击: 调用 `onDelete` 回调，传递分组 ID。
* **实现细节:**
    * 使用 `form.register` 或 `<FormField>` 将 Input/Textarea 绑定到 React Hook Form。
    * 利用 Shadcn UI `FormMessage` 显示验证错误。

**6.2. `RuleEditForm.jsx` 详细设计**

* **Props:**
    * `rule: EspansoRule` - 当前要编辑的规则对象。
    * `onSave: (itemId: string, values: Partial<EspansoRule>) => void` - 保存按钮点击时调用的回调。
    * `onCancel: () => void` - 取消按钮点击时调用的回调。
    * `onDelete: (itemId: string) => void` - 删除按钮点击时调用的回调。
* **内部状态:** 由 React Hook Form 管理表单字段的值、验证状态等；本地状态管理当前选中的“展开内容类型”。
* **表单字段 (使用 Shadcn UI Form 和各种组件):**
    * **缩写语 (trigger):** Text Input, 必填。
    * **描述 (label):** Text Input, 可选。
    * **区分大小写 (caseSensitive):** Switch 或 Checkbox, 可选。
    * **整词匹配 (word):** Switch 或 Checkbox, 可选。
    * **应用限制 (apps):** Multi-select 组件 (可能需要自定义或使用第三方库)，显示可选的应用列表，选择多项，可选。可选的应用列表可能需要从系统中获取或预定义。
    * **优先级 (priority):** Number Input, 可选。
    * **快捷键 (hotkey):** Text Input 或专门的快捷键输入组件，可选。
    * **标签 (tags):** 自定义标签输入组件 (Input + 徽章展示)，支持添加和删除多个标签，可选。
    * **展开内容类型 (contentType):** Select 或 RadioGroup，选项包括：纯文本, 富文本, HTML, 脚本, 图片, 表单, 剪贴板, Shell, 按键 (根据 Espanso 支持的类型列出)。
    * **展开内容 (content):** **这是最复杂的部分，根据 `contentType` 动态渲染不同的输入组件：**
        * **纯文本:** Textarea。
        * **富文本:** 富文本编辑器组件 (如 TinyMCE 或 Quill 的 React 封装)，需要将其集成到 React Hook Form 中。
        * **HTML:** Textarea 或 代码编辑器组件 (如 react-simple-code-editor)，可能需要语法高亮。
        * **脚本:** 代码编辑器组件，支持脚本语言（如 JavaScript/Shell）的语法高亮。
        * **图片:** 图片上传组件 (文件选择对话框或拖拽上传区域)，上传后将图片转换为 Base64 字符串存储在 `content` 字段中。
        * **表单/剪贴板/Shell/按键:** 这些类型在 Espanso 中有特定的结构。`content` 字段可能需要存储 JSON 对象或特定的字符串格式。界面需要根据类型提供相应的输入字段来构建这个结构。例如，表单类型可能需要一个界面来定义表单字段。
* **插入按钮 (时间、变量、剪贴板、系统等):**
    * 这些按钮不直接修改 Zustand store，而是将 Espanso 变量占位符（如 `{{date}}`）插入到当前活动的内容编辑器的光标位置。
    * 这需要获取当前内容编辑器的实例或其暴露的方法，以便在特定位置插入文本。对于标准的 Textarea，可以手动操作 `event.target.selectionStart` 和 `selectionEnd`。对于第三方编辑器，需要查阅其文档了解如何进行编程插入。
    * 可用的变量/功能列表从 `espanzo-utils` 获取，可以使用 Shadcn UI Popover 展示变量列表。
* **预览按钮:**
    * 点击时获取表单当前数据 (`form.getValues()`)。
    * 调用 `espanzo-utils` 中的 `generatePreview` 函数，将表单数据传递给它。
    * 在模态框或组件下方区域显示 `generatePreview` 返回的预览结果。
* **验证:** 使用 Zod 定义 `ruleFormSchema`。对 `content` 字段的验证可能需要根据 `contentType` 进行条件验证。
* **生命周期:**
    * `useEffect` 监听 `rule` 变化，使用 `form.reset(rule)` 更新表单默认值。同时更新本地状态 `currentContentType`。
* **事件处理:**
    * 表单提交 (`form.handleSubmit(onSubmit)`): 调用 `onSave` 回调，传递规则 ID 和表单值。**注意：在调用 `onSave` 前，需要将内部的 `contentType` 和 `content` 转换回 Espanso 配置文件所需的 `replace` 字段的结构，这需要调用 `espanzo-utils` 中的辅助函数。**
    * 取消按钮点击: 调用 `onCancel` 回调。
    * 删除按钮点击: 调用 `onDelete` 回调，传递规则 ID。
    * 内容类型 Select 变化: 更新本地状态 `currentContentType`，并可能清除 `content` 字段的值或根据新类型进行格式化。
* **实现细节:**
    * 集成复杂的第三方编辑器（富文本、代码编辑器）是挑战之一，需要确保它们与 React Hook Form 正确配合。
    * 图片上传需要处理文件读取和 Base64 编码。
    * 处理 Espanso 特定类型（form, clipboard, shell, key）的数据结构和界面输入方式。

**7. 关键功能实现细节 (补充)**

* **YAML 加载和保存的转换细节：**
    * **加载 (`convertToInternalFormat`):**
        * 需要读取 YAML 文件内容 (`readFile`)。
        * 使用 `js-yaml` 解析为 JavaScript 对象 (`parseYaml`)。
        * 遍历解析后的对象，识别出规则、分组和其他可能的 Espanso 配置项（如 `!include`）。
        * 将识别出的规则和分组转换为我们内部的 `EspansoRule` 和 `EspansoGroup` 结构，并生成唯一的 `id`，添加 `createdAt` 和 `updatedAt` 时间戳。
        * 将顶层的规则和分组放入一个虚拟的根分组 (`root`) 的 `children` 数组中。
        * 处理 Espanso 规则中的 `replace` 字段，根据其内容结构（是纯文本、HTML 标签、脚本开头、Base64 字符串等）来判断 `contentType` 并填充到我们内部的 `content` 字段。
        * 递归处理嵌套结构（如果 Espanso 支持）。
        * 添加 `parentId` 属性到每个项目，指向其父分组的 ID。
    * **保存 (`convertToEspansoFormat` 和 `serializeYaml`):**
        * 从 Zustand store 获取内部 `EspansoConfig` 对象。
        * 遍历 `config.root.children`，递归地将内部的 `EspansoRule` 和 `EspansoGroup` 结构转换回 Espanso YAML 所需的对象结构。
        * 将内部的 `contentType` 和 `content` 组合并格式化回 Espanso 的 `replace` 字段。这需要根据 `contentType` 进行不同的处理（例如，脚本类型可能需要在内容前后加上 `|` 和换行符）。
        * 如果支持管理 Espanso 全局设置，也要将其序列化到顶层。
        * 使用 `js-yaml` 将 JavaScript 对象序列化为 YAML 字符串 (`serializeYaml`)。
        * 将 YAML 字符串写入文件 (`writeFile`)。
* **拖拽排序 (React DnD)：**
    * 在 `MiddlePane` 中，每个可拖拽的 `EspansoRule` 或 `EspansoGroup` 项都将包裹在一个自定义的 `DraggableItem` 组件中。
    * `DraggableItem` 组件内部使用 `useDrag` hook，定义拖拽行为和拖拽时携带的数据（如项目的 ID、类型、原始父 ID）。
    * `MiddlePane` 或其内部容器（如每个分组列表）将使用 `useDrop` hook，定义可放置区域以及放置发生时的逻辑。
    * 当拖拽结束 (`drop`) 时，`useDrop` 的逻辑将被触发。它需要知道被拖拽的项目 ID (`draggedItemId`)、目标项目 ID (`targetItemId`) 或目标分组 ID，以及放置的位置 (`position: 'before', 'after', 'into'`)。
    * 然后，调用 Zustand store 的 `moveItem` action，将这些信息传递进去。
    * `moveItem` action 需要执行以下步骤：
        1.  找到 `draggedItemId` 对应的项目，并从其原父节点的 `children` 数组中移除。这需要上面提到的 `removeItemById` 工具函数。
        2.  找到 `targetItemId` 对应的项目或目标分组。
        3.  根据 `position`（'before', 'after', 'into'），将 `draggedItem` 插入到目标位置。
            * `before`/`after targetItemId`: 在 `targetItemId` 所在数组中找到其索引，然后在其前面或后面插入。
            * `into targetGroupId`: 找到 `targetGroupId` 对应的分组，将 `draggedItem` 添加到该分组的 `children` 数组中。如果分组已展开，可以插入到顶部；如果折叠，插入到子数组末尾或标记为在折叠组内。
        4.  更新受影响的分组（原父分组和新父分组）的 `updatedAt` 时间戳。
        5.  使用 Immer 确保状态更新是不可变的。
* **应用限制 (Application Targeting)：**
    * 在 `RuleEditForm` 中，为 `apps` 字段使用一个支持多选的组件。
    * 可供选择的应用列表 (`string[]`) 可以是硬编码的常见应用列表，或者通过 uTools API 尝试获取当前系统已安装的应用列表（如果 uTools 提供了这样的 API）。
    * 选中的应用名称数组存储在规则对象的 `apps` 字段中。
* **标签管理 (Tags)：**
    * 在 `RuleEditForm` 中，为 `tags` 字段创建一个自定义组件。
    * 该组件包含一个输入框和一个区域来显示已添加的标签（使用 Shadcn UI 的徽章 `Badge` 组件）。
    * 用户在输入框输入文本后按回车键，将文本作为新标签添加到标签数组中，并清除输入框。
    * 点击已添加的标签徽章可以将其移除。
    * 标签数组存储在规则对象的 `tags` 字段中。
    * `LeftPane` 需要获取所有规则中使用的唯一标签列表 (`getAllTags` Selector) 并展示，点击标签时更新 `middlePaneFilterTags` 状态。
    * `MiddlePane` 需要根据 `middlePaneFilterTags` 状态过滤显示规则列表。

**8. 技术实施计划与实习生任务分解**

以下是将项目分解为一系列可管理的任务，适合实习生逐步完成。每个任务都应指定负责的文件和核心目标。

1.  **基础环境搭建 (负责人：实习生，指导：你)**
    * 安装所有必要的技术栈依赖 (`npm install`, `npx shadcn-ui add ...`, `npm install zustand react-hook-form react-dnd react-dnd-html5-backend js-yaml uuid`).
    * 配置 Tailwind CSS。
    * 验证 Vite 开发服务器可以正常启动并运行。
2.  **核心数据模型实现 (负责人：实习生，指导：你)**
    * 创建 `src/types/espanzo-config.ts` 文件，精确定义 `BaseItem`, `EspansoRule`, `EspansoGroup`, `EspansoConfig`, `UIState` 接口。
3.  **平台服务层实现 (负责人：实习生，指导：你)**
    * 修改 `public/preload/services.js`，实现 `readFile`, `writeFile`, `showOpenDialog` 函数，并确保 `js-yaml` 在 preload 环境中可用。
    * 更新 `public/preload/package.json` 添加 `js-yaml` 依赖。
4.  **ESPANSO 工具函数基础实现 (负责人：实习生，指导：你)**
    * 创建 `src/utils/espanzo-utils.ts`。
    * 使用 `js-yaml` 实现 `parseYaml` 和 `serializeYaml` 的初步版本（先简单地解析和序列化，暂不处理复杂的 Espanso 结构映射）。
    * 实现 `generateId` 函数 (使用 `uuidv4`).
    * 实现 `findItemById` 函数。
    * 实现 `walkTree` 遍历函数。
    * 实现 `addIdsAndTimestamps` 函数，为所有项目生成 ID 和时间戳。
    * 实现 `removeItemById` 函数。
    * 实现 `insertItemAtIndex` 函数的初步版本（先处理简单插入）。
    * 实现 `convertToInternalFormat` 和 `convertToEspansoFormat` 的初步版本（只处理简单的 rule 和 group 结构，不处理复杂的 content 类型）。**强调这部分后续需要详细完善。**
    * 实现 `getAvailableVariables` (硬编码列表)。
    * `generatePreview` 函数先返回一个占位符字符串。
5.  **Zustand Store 基础实现 (负责人：实习生，指导：你)**
    * 创建 `src/store/useEspansoStore.ts` 文件。
    * 使用 `immer` 创建 store，定义所有状态属性（`config`, `ui`, `loading`, `error`, `configFilePath`）。
    * 实现 `loadConfig` Action：调用 `showOpenDialog` (如果路径未设置)，调用 `readFile` 和 `parseYaml`，调用 `convertToInternalFormat` 和 `addIdsAndTimestamps` 更新 `config` 状态。处理加载失败的情况。
    * 实现 `saveConfig` Action：调用 `convertToEspansoFormat` 和 `serializeYaml`，调用 `writeFile` 保存文件。处理保存失败的情况。
    * 实现 `selectItem` Action。
    * 实现 `setLeftMenuCollapsed` Action。
    * 实现 `addItem`, `updateItem`, `deleteItem` Action 的基础逻辑（调用相应的 Utils 函数更新 `config` 状态）。
    * 实现 `moveItem` Action 的基础逻辑（调用 `removeItemById` 和 `insertItemAtIndex` 更新 `config` 状态）。
    * 实现 `getSelectedItem` 和 `getAllTags` Selectors。
6.  **UI 骨架构建 (负责人：实习生)**
    * 修改 `src/App.jsx`，初始化 store 并在 `onPluginEnter` 中调用 `loadConfig`。渲染 `Layout` 组件。
    * 创建 `src/components/Layout.jsx`，使用 Shadcn UI 组件构建三栏布局。
    * 创建 `src/components/LeftPane.jsx`，使用 Shadcn UI 组件作为菜单栏骨架。
    * 创建 `src/components/MiddlePane.jsx`，使用 Shadcn UI List 组件作为列表骨架，从 store 中获取 `config.root.children` 并初步渲染。
    * 创建 `src/components/RightPane.jsx`，根据 `selectedItemId` 条件渲染不同的占位符文本（如“编辑分组”或“编辑规则”）。
7.  **分组编辑功能实现 (负责人：实习生)**
    * 创建 `src/components/GroupEditForm.jsx`。
    * 使用 React Hook Form 初始化表单，字段包括 `name`, `label`, `prefix`。
    * 使用 Shadcn UI Form, Input, Textarea 构建表单 UI。
    * 使用 Zod 定义 `groupFormSchema` 进行验证。
    * 在 `useEffect` 中实现当 `group` props 变化时重置表单。
    * 连接 Save, Cancel, Delete 按钮到相应的 props 回调。
8.  **规则编辑功能实现 (基础部分) (负责人：实习生)**
    * 创建 `src/components/RuleEditForm.jsx`。
    * 使用 React Hook Form 初始化表单，包含基础字段：`trigger`, `label`, `caseSensitive`, `word`, `priority`, `contentType`, `content`。
    * 使用 Shadcn UI Form, Input, Textarea, Switch, Select 构建基础表单 UI。
    * 使用 Zod 定义 `ruleFormSchema` 进行验证。
    * 在 `useEffect` 中实现当 `rule` props 变化时重置表单。
    * 连接 Save, Cancel, Delete 按钮到相应的 props 回调。
    * 实现 `contentType` Select 的值变化时，更新本地状态 `currentContentType`。
    * 使用 Shadcn UI Tabs 实现内容编辑区域的切换，但先只在“纯文本” Tab 中放一个 Textarea。
9.  **拖拽排序功能实现 (负责人：实习生，重点指导)**
    * 创建 `src/components/DraggableItem.jsx`。
    * 在 `DraggableItem` 中使用 `useDrag` Hook，定义拖拽类型和数据。
    * 在 `MiddlePane` 中，使用 `DndProvider` 包裹列表。
    * 在 `MiddlePane` 或其内部容器中使用 `useDrop` Hook，定义放置区域。
    * 实现 `drop` 发生时，调用 Zustand store 的 `moveItem` Action。**需要仔细指导如何从 DnD 事件中获取正确的信息 (draggedItemId, targetItemId, position)。**
    * 在 `MiddlePane` 渲染时，根据 `config.root.children` 递归渲染 `DraggableItem`。
10. **高级规则编辑功能实现 (负责人：实习生，重点指导)**
    * 完善 `RuleEditForm.jsx`。
    * 实现应用限制 (apps): 使用第三方多选组件或自定义实现，获取可选应用列表。
    * 实现标签管理 (tags): 创建 `TagInput` 自定义组件，集成到 `RuleEditForm`。
    * 完善内容类型编辑区域：
        * **富文本/HTML/脚本：** 集成第三方编辑器组件 (需要额外安装)。**指导如何将第三方编辑器与 React Hook Form 集成（使用 `Controller` 或自定义注册逻辑）。**
        * **图片：** 实现图片上传功能，将文件转换为 Base64。
    * 实现插入变量/时间/剪贴板按钮：获取 `availableVariables`，实现点击按钮在内容编辑器中插入文本的功能。
    * 实现预览按钮：调用 `generatePreview`，显示结果。
11. **工具函数和格式转换完善 (负责人：你 或 经验更丰富的开发者，指导实习生理解)**
    * **仔细研究 Espanso 官方文档，精确实现 `convertToInternalFormat` 和 `convertToEspansoFormat`，确保所有 Espanso 支持的规则属性和内容类型都能正确映射。**特别是 `replace` 字段的解析和序列化逻辑。
    * 完善 `generatePreview` 函数，使其尽可能模拟 Espanso 的展开行为。
12. **左侧菜单和标签过滤实现 (负责人：实习生)**
    * 完善 `LeftPane.jsx`。
    * 使用 `getAllTags` Selector 获取所有标签。
    * 渲染标签列表，点击标签更新 `middlePaneFilterTags` 状态。
    * 在 `MiddlePane` 中根据 `middlePaneFilterTags` 过滤渲染列表项。
13. **导入/导出功能实现 (负责人：实习生，指导：你)**
    * 在 UI 中添加导入/导出按钮。
    * 导入：调用 `showOpenDialog` 选择文件，`readFile` 读取文件内容，`parseYaml` 解析，`convertToInternalFormat` 转换为内部结构，更新 Zustand store。
    * 导出：从 Zustand store 获取 `config`，`convertToEspansoFormat` 转换为 Espanso 格式，`serializeYaml` 序列化为 YAML，调用 `writeFile` 将内容写入用户指定的文件（可能需要 `showSaveDialog` 如果 uTools 提供）。
14. **错误处理和通知 (负责人：实习生)**
    * 在文件操作、YAML 处理、表单验证等地方添加 try...catch 块。
    * 使用 uTools 的 `showNotification` 显示错误和成功提示。
    * 利用 React Hook Form 的验证错误提示。
15. **测试和优化 (负责人：你 和 实习生)**
    * 进行功能测试，确保所有功能按预期工作。
    * 检查跨平台兼容性。
    * 进行代码审查，确保代码结构清晰，业务逻辑封装良好。
    * 进行性能优化（如果需要）。

**9. 指导与支持策略**

* **明确的任务分配：** 每次只分配少量具体、边界清晰的任务。
* **代码示例：** 对于复杂的功能（如 Zustand Actions 中的 Immer 使用、React DnD 实现、自定义表单控件），提供简洁的代码示例。
* **数据结构解释：** 反复强调内部数据模型的结构和不同字段的含义，以及它与 Espanso YAML 的映射关系。
* **逐步集成：** 鼓励实习生逐步集成不同的库和功能，先实现核心流程，再添加高级特性。
* **定期沟通：** 每天或每隔一段时间进行简短的站会或交流，了解进展、解决问题、提供指导。
* **重点代码审查：** 对包含业务逻辑较多或容易出错的部分（如 Zustand Actions, YAML 转换 Utils, DnD 实现）进行更详细的代码审查。
* **鼓励提问：** 创造一个开放的环境，让实习生敢于提问，即使是看似简单的问题。

**10. 风险与缓解**

* **风险：** Espanso YAML 配置文件格式的复杂性和未完全覆盖性。特别是高级功能（form, script, key, shell）的 `replace` 结构可能非常多样。
    * **缓解：** 投入专门时间深入研究 Espanso 官方文档中关于所有可配置项和 `replace` 字段结构的详细说明。将 YAML 解析和序列化逻辑视为核心且高风险部分，由你或经验丰富的开发者主导设计和关键代码实现，并提供详细的规范给实习生。如果某些高级功能过于复杂，可以考虑在第一阶段 MVP 中暂不完全支持，后续迭代添加。
* **风险：** 实习生在实现涉及状态更新和组件交互的复杂业务逻辑时遇到困难（如拖拽排序、动态表单）。
    * **缓解：** 将这些复杂功能分解为更小的步骤。提供详细的伪代码或实现思路。利用 Zustand 和 React Hook Form 提供的模式来封装逻辑。在实现过程中进行密切的代码审查和手把手指导。确保状态更新使用 Immer，避免不可变性问题。
* **风险：** 第三方库（React DnD, 富文本编辑器等）的集成和与 React Hook Form 的配合。
    * **缓解：** 提供清晰的集成示例。指导实习生查阅第三方库和 React Hook Form 的官方文档。必要时，可以先由你实现一个简单的集成示例组件，供实习生参考。
* **风险：** 跨平台文件路径和权限问题。
    * **缓解：** 在 Preload Script 中处理文件路径时，使用 Node.js 的 `path` 模块 (`path.join`) 来构建路径，以保证跨平台兼容性。处理文件写入时，考虑潜在的权限问题，并在 Preload Script 中捕获并通知用户。

通过这份详细的技术方案，你应该能够有效地指导你的实习生完成 ESPANSO 配置管理工具的开发。祝项目成功，早日实现你的梦想！

---