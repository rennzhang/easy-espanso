好的，顶级架构师为你准备了一份更完整、更详细的技术方案文档。这份文档旨在为你的实习生提供清晰的指导，让他能够系统地完成 ESPANSO 配置管理工具的开发，同时最大程度地规避业务逻辑组织上的障碍。

---

**文档标题：ESPANSO 配置管理工具 uTools 插件技术方案**

**版本：1.0**

**日期：2025年4月26日**

**作者：[你的名字/顶级架构师]**

**1. 引言**

本文档旨在详细阐述基于 uTools 平台开发 ESPANSO 配置管理工具的技术方案。项目的核心目标是提供一个用户友好的图形化界面，以替代 ESPANSO 传统的 YAML 文件编辑方式，从而降低用户学习曲线，提高配置效率。考虑到项目开发人员在业务逻辑组织方面存在的挑战，本方案着重于构建清晰的分层架构，严格分离用户界面、业务逻辑和底层服务，确保开发人员能够专注于其擅长的纯粹编码任务。

**2. 总体架构设计**

本项目的架构遵循经典的三层模式，并根据 uTools 插件的特性进行调整：

* **展现层 (Presentation Layer):** 基于 Vue 3 和 Nuxt UI 构建用户界面。负责接收用户输入、展示数据和 UI 状态。这一层将保持“纯粹”，不包含业务逻辑，只负责调用应用逻辑层提供的方法和根据应用逻辑层提供的状态进行渲染。
* **应用逻辑层 (Application Logic Layer):** 使用 Pinia 管理全局应用状态和业务逻辑。负责协调展现层和底层服务层，处理用户操作引起的业务流程，如数据的增删改查、排序、过滤、验证等。复杂的状态变化和业务规则将集中在此层处理。
* **服务层 (Service Layer):** 提供与外部系统或复杂功能交互的能力。
    * **平台服务 (uTools Preload Script):** 利用 uTools 的 Node.js 能力，提供文件系统访问（读写 ESPANSO 配置文件）和系统对话框（选择目录）等与操作系统交互的功能。
    * **ESPANSO 特有服务 (Utils Module):** 包含处理 ESPANSO 配置文件格式（YAML 解析/序列化）和 ESPANSO 特有功能（内置变量、功能函数、规则预览）的纯函数工具集。

**架构示意图：**

```mermaid
graph TD
    A[用户] --> B[UI Layer (Vue 3 / Nuxt UI)]
    B --> C[Application Logic Layer (Pinia Store)]
    C --> D[Service Layer]
    D --> D1[Platform Service (Preload Script)]
    D --> D2[Espanso Specific Service (Utils)]
    D1 --> E[文件系统 / 操作系统]
    D2 --> F[Espanso 配置文件格式 / 功能]
    C --> B
    D --> C
```

**职责划分：**

* **UI 组件 (Vue SFC):** 负责渲染 (`<template>`)；通过 `@click`, `@change` 等事件触发方法 (`<script setup>`)，方法中调用 Pinia Actions；通过 Pinia Store (`state`, `getters`) 获取状态进行展示。
* **Pinia Store：** 负责存储应用状态 (`state`)；定义 Actions 来修改状态；Actions 中可以调用 Service Layer 的方法完成业务逻辑；定义 Getters 计算派生状态。
* **Preload Script：** 负责执行 Node.js API 调用；不包含业务逻辑或 UI 状态。
* **Utils Module：** 负责纯粹的数据转换和计算；不包含业务逻辑或 UI 状态。

**3. 技术栈选型**

* **前端框架:** Vue 3 (使用 `<script setup>`)
* **构建工具:** Vite (已提供)
* **UI 组件库:** Nuxt UI (基于 Headless UI & Tailwind CSS) - 提供美观、可访问、可定制的 Vue 组件。
* **样式:** Tailwind CSS - Nuxt UI 内置集成，提供原子化 CSS 类，方便样式定制。
* **状态管理:** Pinia - Vue 官方推荐的状态管理库，类型安全且易于使用。
* **表单管理:** Nuxt UI 表单组件 + Vuelidate - Nuxt UI 提供表单元素，Vuelidate 提供强大的数据验证能力。
* **拖拽功能:** VueDraggableNext (基于 SortableJS) - 流行的 Vue 3 拖拽库，用于实现分组和规则的拖拽排序。
* **YAML 处理:** `js-yaml` - 用于解析和序列化 YAML 配置文件。在 Preload Script 和 Renderer Process 中都需要使用。
* **唯一 ID 生成:** `uuid` (推荐) - 用于为分组和规则生成唯一的标识符，方便状态管理和查找。
* **平台 API:** uTools API - 用于获取应用进入参数、显示通知、打开文件对话框等。
* **文件系统 API:** Node.js `fs` 和 `path` 模块 - 通过 Preload Script 访问。

**4. 数据模型设计 (TypeScript)**

以下是应用内部使用的数据模型定义，用于在 Zustand store 中存储 ESPANSO 配置数据。这与实际的 ESPANSO YAML 结构会有映射关系，但在应用内部更便于操作。

```typescript
// src/types/espanzo-config.ts

// 定义所有项目（规则或分组）共享的基础属性
export interface BaseItem {
  id: string; // 唯一的标识符，用于在应用内部识别和管理
  type: 'rule' | 'group'; // 项目类型
  label?: string; // 用户友好的描述或名称
  createdAt: number; // 创建时间戳，用于排序
  updatedAt: number; // 最后修改时间戳，用于排序和优先级判断
  // 内部使用属性，方便UI层展示，不一定直接映射到Espanso配置
  isExpanded?: boolean; // 用于分组折叠状态
}

// 定义规则的属性
export interface EspansoRule extends BaseItem {
  type: 'rule';
  trigger: string; // 触发词，如 ":date"
  // 在应用内部，我们将Espanso的'replace'字段拆解为contentType和content
  contentType: 'plain' | 'rich' | 'html' | 'script' | 'image' | 'form' | 'clipboard' | 'shell' | 'key'; // Espanso支持的内容类型
  content: string | any; // 实际内容，根据contentType可以是字符串、脚本代码、base64图片等，form等复杂类型可能需要更详细的结构
  caseSensitive?: boolean; // 是否区分大小写
  word?: boolean; // 是否整词匹配
  apps?: string[]; // 生效的应用列表，空数组或undefined表示所有应用
  priority?: number; // 规则优先级 (数字越大优先级越高)
  hotkey?: string; // 快捷键触发 (如果Espanso支持)
  tags?: string[]; // 标签数组
  // Espanso还支持其他一些高级属性，如vars, form, key, shell等，需要根据文档补充到content或独立字段中
  // 例如，如果contentType是'form'，content可能是一个表示表单结构的JSON对象
}

// 定义分组的属性
export interface EspansoGroup extends BaseItem {
  type: 'group';
  name: string; // 分组名称，用户可读
  prefix?: string; // 分组公共前缀，应用于组内所有规则 (如果Espanso支持组级前缀)
  children: Array<EspansoRule | EspansoGroup>; // 嵌套的规则和分组
  // 内部使用属性，方便UI层展示，不一定直接映射到Espanso配置
  parentId: string | 'root'; // 父分组的ID，'root'表示顶层
}

// 定义整个ESPANSO配置的结构
export interface EspansoConfig {
  // Espanso配置的顶层结构可能是一个包含rules和includes的数组
  // 在我们的应用内部，我们将其映射为一个虚拟的根分组，方便树状结构管理
  root: EspansoGroup; // 虚拟的根分组，其children包含顶层所有规则和分组
  // 其他全局设置，如backend, listen_clipboard等，如果需要管理，也可以添加到这里
  globalSettings?: {
      backend?: string;
      listen_clipboard?: boolean;
      // ... other global settings
  };
}

// 定义应用界面的状态
export interface UIState {
  selectedItemId: string | null; // 当前在右侧编辑面板选中的项目ID
  isEditing: boolean; // 是否正在编辑状态 (可以用于控制按钮禁用状态)
  leftMenuCollapsed: boolean; // 左侧菜单是否收起
  middlePaneFilterTags: string[]; // 中间面板按标签过滤的状态
  // ... 其他UI状态
}
```

**5. 应用逻辑层 (Pinia Store)**

Pinia store 将是应用的核心状态容器和业务逻辑处理中心，负责管理应用数据和协调各层交互。

```typescript
// src/store/useEspansoStore.ts
import { defineStore } from 'pinia';
import { EspansoConfig, EspansoRule, EspansoGroup, BaseItem, UIState } from '../types/espanzo-config';
import { readFile, writeFile, showOpenDialog } from '../services/fileService'; // 从 preload 导入的服务 (保持不变)
import {
    parseYaml,
    serializeYaml,
    generateId,
    findItemById,
    removeItemById,
    insertItemAtIndex,
    walkTree,
    convertToInternalFormat,
    convertToEspansoFormat,
    addIdsAndTimestamps,
    setParentIds, // Ensure this is exported if needed elsewhere, or used internally
    getAvailableVariables,
    generatePreview
} from '../utils/espanzo-utils'; // 从 utils 导入的工具函数 (保持不变)

// 定义 Pinia Store 的 State 类型
interface EspansoState {
  config: EspansoConfig | null;
  ui: UIState;
  loading: boolean;
  error: string | null;
  configFilePath: string | null; // 存储当前配置文件的路径
}

export const useEspansoStore = defineStore('espanso', {
  // State
  state: (): EspansoState => ({
    config: null,
    ui: {
      selectedItemId: null,
      isEditing: false, // 表单编辑状态可能由组件本地管理，或在此处同步
      leftMenuCollapsed: false,
      middlePaneFilterTags: [],
    },
    loading: false,
    error: null,
    configFilePath: null,
  }),

  // Getters (类似 Vue Computed Properties)
  getters: {
    // 获取当前选中的项目
    selectedItem(state): BaseItem | EspansoRule | EspansoGroup | null {
      if (!state.config || !state.ui.selectedItemId) return null;
      // 注意：findItemById 需要能够处理根节点下的 children
      return findItemById(state.config.root.children, state.ui.selectedItemId);
    },
    // 获取所有唯一的标签
    allTags(state): string[] {
      if (!state.config) return [];
      const tags = new Set<string>();
      // walkTree 需要能正确遍历 state.config.root
      walkTree(state.config.root, (item) => {
        if (item.type === 'rule' && item.tags) {
          item.tags.forEach(tag => tags.add(tag));
        }
        return false; // Continue walking
      });
      return Array.from(tags);
    },
    // 可以添加更多 getters，例如获取过滤后的项目列表等
  },

  // Actions (修改 state 的方法)
  actions: {
    // 加载配置文件
    async loadConfig(filePath?: string) {
      this.loading = true;
      this.error = null;
      if (filePath) {
        this.configFilePath = filePath;
      }

      if (!this.configFilePath) {
        try {
          const selectedDirs = await showOpenDialog({
            title: '请选择 ESPANSO 配置文件夹 (包含 default.yml 的目录)',
            properties: ['openDirectory']
          });

          if (!selectedDirs || selectedDirs.length === 0) {
            this.loading = false;
            this.error = '未选择有效的 ESPANSO 配置文件夹。';
            return;
          }
          // 根据操作系统猜测 default.yml 的路径
          const guessedFilePath = `${selectedDirs[0]}/${process.platform === 'win32' ? 'config\\default.yml' : 'config/default.yml'}`;
          this.configFilePath = guessedFilePath;
          // 重新调用 loadConfig 加载
          await this.loadConfig(); // Recursive call with path now set
          return; // Stop current execution after recursive call finishes

        } catch (err: any) {
            console.error("Error selecting directory:", err);
            this.loading = false;
            this.error = `选择目录时出错: ${err.message}`;
            window.utools?.showNotification?.('选择目录失败！');
            return;
        }
      }


      try {
        const content = await readFile(this.configFilePath);
        const parsedData = parseYaml(content);

        // TODO: 验证 parsedData 结构
        // TODO: 实现健壮的 convertToInternalFormat
        const internalConfig = convertToInternalFormat(parsedData);
        // TODO: 实现健壮的 addIdsAndTimestamps
        const configWithIdsAndTimestamps = addIdsAndTimestamps(internalConfig);
        // TODO: 实现 setParentIds (如果需要在加载后设置)
        // setParentIds(configWithIdsAndTimestamps.root); // Example call

        this.config = configWithIdsAndTimestamps;
        this.loading = false;
        this.error = null;

      } catch (err: any) {
        console.error("Failed to load or parse config:", err);
        this.config = null; // Clear potentially invalid config
        this.loading = false;
        this.error = `加载或解析配置文件失败: ${err.message}`;
        this.configFilePath = null; // 清除路径，以便下次加载时重新提示
        window.utools?.showNotification?.('加载配置文件失败，请检查文件或重新选择目录。');
      }
    },

    // 保存配置文件
    async saveConfig() {
      if (!this.config || !this.configFilePath) {
        this.error = '无法保存：配置或文件路径无效。';
        window.utools?.showNotification?.('无法保存：配置或文件路径无效。');
        return;
      }
      this.loading = true;
      this.error = null;
      try {
        // TODO: 实现健壮的 convertToEspansoFormat
        const espansoFormatData = convertToEspansoFormat(this.config);
        const yamlContent = serializeYaml(espansoFormatData);
        await writeFile(this.configFilePath, yamlContent);
        this.loading = false;
        window.utools?.showNotification?.('配置文件保存成功！');
      } catch (err: any) {
        console.error("Failed to save config:", err);
        this.loading = false;
        this.error = `保存文件失败: ${err.message}`;
        window.utools?.showNotification?.('文件保存出错了！');
      }
    },

    // 选择项目
    selectItem(itemId: string | null) {
      this.ui.selectedItemId = itemId;
      // this.ui.isEditing = false; // Optionally reset editing state
    },

    // 设置左侧菜单折叠状态
    setLeftMenuCollapsed(collapsed: boolean) {
      this.ui.leftMenuCollapsed = collapsed;
    },

    // 添加项目 (规则或分组)
    addItem(parentGroupId: string | 'root', type: 'rule' | 'group', initialData?: Partial<EspansoRule | EspansoGroup>) {
      if (!this.config) return;

      const now = Date.now();
      const newItem: BaseItem = {
        id: generateId(),
        type,
        createdAt: now,
        updatedAt: now,
        label: (initialData as any)?.label || (type === 'rule' ? '新规则' : '新分组'),
        ...initialData as any,
        ...(type === 'group' ? { children: [] as (EspansoRule | EspansoGroup)[], parentId: parentGroupId, isExpanded: true } : {}),
        ...(type === 'rule' ? { trigger: (initialData as any)?.trigger || '', content: (initialData as any)?.content || '', contentType: (initialData as any)?.contentType || 'plain' } : {}),
      };

      // Pinia 中可以直接修改 state，但对于深层嵌套对象的操作，推荐使用辅助函数或确保响应性
      // walkTree 可以在这里使用来查找父节点并修改其 children
      let parentFound = false;
      walkTree(this.config.root, (item, parent) => {
        if ((parentGroupId === 'root' && item.id === this.config?.root.id) || (item.type === 'group' && item.id === parentGroupId)) {
          // 确保 children 是响应式的，如果直接 push 可能需要 Vue.set 或确保父对象是 reactive
          // 在 Pinia 中，直接修改通常是安全的，因为它使用 Proxy
          item.children.push(newItem as any);
          // 更新父节点的 parentId (如果需要)
          if (newItem.type === 'group') {
              (newItem as EspansoGroup).parentId = item.id;
          } else {
               (newItem as EspansoRule).parentId = item.id; // Assuming rules also need parentId internally
          }
          this.ui.selectedItemId = newItem.id; // Select the newly added item
          parentFound = true;
          return true; // Stop walking
        }
        return false; // Continue walking
      });

      if (!parentFound) {
          console.error("Parent group not found for adding item:", parentGroupId);
      }
    },

    // 更新项目
    updateItem(itemId: string, updates: Partial<EspansoRule | EspansoGroup>) {
      if (!this.config) return;

      let itemFound = false;
      walkTree(this.config.root, (item) => {
        if (item.id === itemId) {
          // 直接合并更新，Pinia 会处理响应性
          Object.assign(item, updates);
          item.updatedAt = Date.now(); // 更新时间戳
          itemFound = true;
          return true; // Stop walking
        }
        return false; // Continue walking
      });
       if (!itemFound) {
           console.error("Item not found for update:", itemId);
       }
    },

    // 删除项目
    deleteItem(itemId: string) {
      if (!this.config) return;

      // 使用 removeItemById 工具函数 (它需要返回更新后的根节点)
      const [updatedRoot, removedItemParentId] = removeItemById(this.config.root, itemId);

      if (updatedRoot) {
        // 直接替换整个 root 对象以确保响应性，或者如果 removeItemById 内部处理了响应性则不需要
        this.config.root = updatedRoot; // Assuming removeItemById returns a new root object or modifies in place reactively
        // 如果删除的是当前选中的项，则取消选中
        if (this.ui.selectedItemId === itemId) {
          this.ui.selectedItemId = null;
        }
      } else {
        console.error("Item not found for deletion:", itemId);
      }
    },

    // 移动项目 (拖拽)
    moveItem(draggedItemId: string, targetItemId: string | 'root', position: 'before' | 'after' | 'into') {
      if (!this.config) return;

      // 1. 查找并移除被拖拽项
      let draggedItem: EspansoRule | EspansoGroup | null = null;
      const [tempRootAfterRemoval, sourceParentId] = removeItemById(this.config.root, draggedItemId, (item) => {
          // Clone the item to avoid issues if it's immediately re-inserted
          draggedItem = JSON.parse(JSON.stringify(item));
      });


      if (!draggedItem || !tempRootAfterRemoval) {
        console.error("Dragged item not found or removal failed:", draggedItemId);
        // Optionally revert state or handle error
        return;
      }


      // 2. 插入到新位置
      // insertItemAtIndex 需要返回更新后的根节点
      const updatedRoot = insertItemAtIndex(tempRootAfterRemoval, targetItemId, draggedItem, position);

      if (updatedRoot) {
        // 更新 parentId for the moved item
        walkTree(updatedRoot, (item, parent) => {
            if (item.id === draggedItemId && parent) {
                 (item as any).parentId = parent.id;
                 item.updatedAt = Date.now(); // Update timestamp
                 return true; // Stop walking once found and updated
            }
            return false;
        });
        this.config.root = updatedRoot; // Update the state
      } else {
        console.error("Failed to insert item:", draggedItemId, "into", targetItemId, "at", position);
        // Revert state if insertion failed? This might be complex.
        // Maybe reload the original config or notify user.
        // For simplicity, we might just log the error here.
        // Consider re-adding the removed item back to its original position if insert fails.
      }
    },
    // ... 其他 actions
  }
});
```

**需要实习生实现的 `espanzo-utils.ts` 关键工具函数 (供 Pinia Actions 调用)：**

这些工具函数大部分保持不变，因为它们是纯粹的数据处理逻辑，不依赖于前端框架或状态管理库。主要变化在于调用它们的上下文从 Zustand Actions 变成了 Pinia Actions。

```typescript
// src/utils/espanzo-utils.ts
import yaml from 'js-yaml';
import { EspansoConfig, EspansoRule, EspansoGroup, BaseItem } from '../types/espanzo-config';
import { v4 as uuidv4 } from 'uuid'; // Using uuid library

// 生成唯一ID (不变)
export function generateId(): string {
    return uuidv4();
}

// 递归遍历树结构 (不变)
export function walkTree(item: EspansoGroup | EspansoRule, callback: (item: EspansoRule | EspansoGroup, parent: EspansoGroup | null) => boolean | void, parent: EspansoGroup | null = null): boolean {
    if (callback(item, parent)) {
        return true; // Stop traversal if callback returns true
    }
    if (item.type === 'group' && item.children) {
        for (const child of item.children) {
            if (walkTree(child, callback, item)) {
                 return true; // Stop if child traversal stops
            }
        }
    }
    return false; // Continue traversal
}


// 查找指定ID的项目 (不变)
export function findItemById(items: Array<EspansoRule | EspansoGroup>, id: string): EspansoRule | EspansoGroup | null {
    for (const item of items) {
        if (item.id === id) {
            return item;
        }
        if (item.type === 'group' && item.children) {
            const found = findItemById(item.children, id);
            if (found) return found;
        }
    }
    return null;
}

// 从树结构中移除指定ID的项目，并返回移除后的根节点和移除项的父ID (不变)
// 注意：此函数应返回一个新的根节点对象，以确保 Pinia 的响应性。
export function removeItemById(root: EspansoGroup, id: string, onRemove?: (item: EspansoRule | EspansoGroup, parentId: string | 'root') => void): [EspansoGroup | null, string | 'root' | null] {
    let removedParentId: string | 'root' | null = null;
    let itemRemoved = false;
    // 创建根节点的浅拷贝以进行修改
    const newRoot = { ...root, children: [...root.children] };

    const filterChildren = (items: Array<EspansoRule | EspansoGroup>, parentId: string | 'root'): Array<EspansoRule | EspansoGroup> => {
        return items.reduce((acc, item) => {
            if (item.id === id) {
                itemRemoved = true;
                removedParentId = parentId;
                if (onRemove) onRemove(item, parentId);
                // 不将此项添加到 acc 中
            } else {
                const newItem = { ...item }; // 浅拷贝当前项
                if (newItem.type === 'group') {
                    // 递归处理子项，并更新 newItem 的 children
                    newItem.children = filterChildren(newItem.children, newItem.id);
                }
                acc.push(newItem); // 将处理后的项添加到 acc
            }
            return acc;
        }, [] as Array<EspansoRule | EspansoGroup>);
    };

    newRoot.children = filterChildren(newRoot.children, newRoot.id);

    if (itemRemoved) {
        return [newRoot, removedParentId]; // 返回新的根节点
    }
    return [null, null]; // Item not found
}


// 将项目插入到指定位置 (用于拖拽) (不变)
// 注意：此函数应返回一个新的根节点对象，以确保 Pinia 的响应性。
export function insertItemAtIndex(
    root: EspansoGroup,
    targetItemId: string | 'root',
    itemToInsert: EspansoRule | EspansoGroup,
    position: 'before' | 'after' | 'into'
): EspansoGroup | null {
    let inserted = false;
    // 创建根节点的浅拷贝
    const newRoot = { ...root, children: [...root.children] };

    const insert = (items: Array<EspansoRule | EspansoGroup>, parentId: string | 'root'): Array<EspansoRule | EspansoGroup> => {
        const newItems: Array<EspansoRule | EspansoGroup> = [];
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const newItem = { ...item }; // 浅拷贝当前项

            if (newItem.id === targetItemId) {
                if (position === 'before') {
                    newItems.push(itemToInsert);
                    newItems.push(newItem);
                    inserted = true;
                } else if (position === 'after') {
                    newItems.push(newItem);
                    newItems.push(itemToInsert);
                    inserted = true;
                } else if (position === 'into' && newItem.type === 'group') {
                    // 确保 children 存在且为数组
                    newItem.children = newItem.children ? [itemToInsert, ...newItem.children] : [itemToInsert];
                    newItems.push(newItem);
                    inserted = true;
                } else {
                    // Cannot drop 'into' a rule or invalid position
                    newItems.push(newItem);
                }
            } else {
                 if (newItem.type === 'group') {
                    // 递归处理子项，并更新 newItem 的 children
                    newItem.children = insert(newItem.children, newItem.id);
                 }
                 newItems.push(newItem);
            }
        }
         // Handle insertion relative to the parent if target is not found in children (e.g., dropping into an empty group or root)
         if (!inserted && parentId === targetItemId && position === 'into') {
              newItems.push(itemToInsert); // Add as the last child
              inserted = true;
         }

        return newItems;
    };

    // Handle dropping directly into the root group
    if (targetItemId === newRoot.id && position === 'into') {
        newRoot.children.push(itemToInsert); // Add to the end
        inserted = true;
    } else {
        newRoot.children = insert(newRoot.children, newRoot.id);
    }


    if (inserted) {
        return newRoot; // 返回新的根节点
    }

    console.error("Item not inserted. Target or position might be invalid.", targetItemId, position);
    return null; // Indicate insertion failed
}


// 将 Espanso 的 YAML 格式转换为我们的内部数据模型 (不变)
export function convertToInternalFormat(espansoData: any): EspansoConfig {
    const rootGroup: EspansoGroup = {
        id: 'root', // 虚拟根ID
        type: 'group',
        name: '所有配置', // 或从 Espanso 全局设置中获取名称
        createdAt: Date.now(), // 或使用文件修改时间
        updatedAt: Date.now(), // 或使用文件修改时间
        children: [],
        parentId: 'root', // 根节点的父ID是自身或者一个特殊标记
        isExpanded: true, // 默认展开根节点
    };

    // 假设 espansoData 的顶层是 { matches: [...] }
    if (espansoData && Array.isArray(espansoData.matches)) {
        espansoData.matches.forEach((itemData: any) => {
            // TODO: 根据 itemData 的结构判断是规则还是分组或 include
            if (itemData.trigger && itemData.replace !== undefined) { // Likely a rule
                 const rule: EspansoRule = {
                     id: generateId(), // 生成内部ID
                     type: 'rule',
                     createdAt: Date.now(), // Placeholder, ideally from file metadata or Espanso config
                     updatedAt: Date.now(), // Placeholder
                     trigger: itemData.trigger,
                     label: itemData.label || '', // Use label if exists
                     // TODO: 将 itemData.replace 的结构解析为 contentType 和 content
                     contentType: 'plain', // Placeholder
                     content: itemData.replace, // Placeholder

                     caseSensitive: itemData.case_sensitive,
                     word: itemData.word,
                     apps: itemData.apps,
                     priority: itemData.priority,
                     hotkey: itemData.key, // Map Espanso 'key' to hotkey
                     tags: itemData.tags,
                      // Map other Espanso rule properties
                 };
                 rootGroup.children.push(rule);
            } else if (itemData.name && Array.isArray(itemData.matches)) { // Likely a group (based on nested matches?)
                 // Espanso's grouping might be represented differently. Need to confirm.
                 // This is a simplified assumption for nested structure.
                  // If Espanso groups are just comments or includes, this needs adjustment.
                 // Let's assume for now a structure like { name: 'GroupName', matches: [...] } represents a group
                 const group: EspansoGroup = {
                      id: generateId(),
                      type: 'group',
                      name: itemData.name,
                      createdAt: Date.now(),
                      updatedAt: Date.now(),
                      children: [], // Recursively process children? Or shallow initially?
                      parentId: rootGroup.id,
                       prefix: itemData.prefix, // If group has prefix
                       isExpanded: true,
                 };
                 // Recursively convert children if needed
                 if(itemData.matches) {
                      itemData.matches.forEach((childData: any) => {
                           // TODO: Convert childData and add to group.children
                           // This needs a recursive call or helper
                            if (childData.trigger) {
                                const childRule: EspansoRule = {
                                    id: generateId(),
                                    type: 'rule',
                                     createdAt: Date.now(),
                                    updatedAt: Date.now(),
                                    trigger: childData.trigger,
                                    label: childData.label || '',
                                     contentType: 'plain', // Placeholder
                                     content: childData.replace, // Placeholder
                                     // ... map other rule properties
                                };
                                group.children.push(childRule);
                            }
                            // Handle nested groups if Espanso supports it this way
                      });
                 }
                 rootGroup.children.push(group);

            }
             // TODO: Handle '!include' directives - maybe represent as a special item type?
        });
    } else {
         // Handle other potential root structures or throw error if unexpected
          console.warn("Espanso config root structure not as expected (missing matches array).", espansoData);
          // Attempt to parse top-level items directly if not in 'matches'
          // This is a fallback and might not cover all cases.
           if (espansoData.trigger) { // If it looks like a single rule at the top level
               const rule: EspansoRule = {
                     id: generateId(),
                     type: 'rule',
                     createdAt: Date.now(),
                     updatedAt: Date.now(),
                     trigger: espansoData.trigger,
                     label: espansoData.label || '',
                      contentType: 'plain', // Placeholder
                     content: espansoData.replace, // Placeholder
                      // ... map other rule properties
                 };
                 rootGroup.children.push(rule);
           }
    }


     // TODO: After initial parsing, add parentId to all items for easier traversal
     walkTree(rootGroup, (item, parent) => {
         if (item.id !== rootGroup.id && parent) {
              (item as any).parentId = parent.id;
         } else if (item.id === rootGroup.id) {
              (item as any).parentId = 'root'; // Mark root parent
         }
          return false;
     });


    return { root: rootGroup };
}


// 将内部数据模型转换回 Espanso 的 YAML 格式 (不变)
export function convertToEspansoFormat(internalConfig: EspansoConfig): any {
    const espansoMatches: any[] = [];

    // Recursively convert internal items to Espanso format
    const convertItems = (items: Array<EspansoRule | EspansoGroup>): any[] => {
        const espansoItems: any[] = [];
        items.forEach(item => {
            if (item.type === 'rule') {
                const espansoRule: any = {
                    trigger: item.trigger,
                    // TODO: 将 item.contentType 和 item.content 转换回 Espanso 的 replace 结构
                    // This is complex, especially for form, clipboard, shell, key types.
                    // Need to handle serialization based on contentType.
                    replace: item.content, // Simple placeholder mapping
                     // Map other rule properties back to Espanso names
                    ...(item.label && { label: item.label }),
                    ...(item.caseSensitive !== undefined && { case_sensitive: item.caseSensitive }),
                    ...(item.word !== undefined && { word: item.word }),
                    ...(item.apps && item.apps.length > 0 && { apps: item.apps }),
                    ...(item.priority !== undefined && item.priority !== 0 && { priority: item.priority }), // Only include if not default
                    ...(item.hotkey && { key: item.hotkey }), // Map hotkey back to Espanso 'key'
                    ...(item.tags && item.tags.length > 0 && { tags: item.tags }),
                     // Include other Espanso specific rule properties
                };
                espansoItems.push(espansoRule);
            } else if (item.type === 'group') {
                 // TODO: Convert group structure back to Espanso format
                 // Assuming Espanso groups are represented by nested matches with a name/prefix
                 const espansoGroup: any = {
                      name: item.name,
                      ...(item.prefix && { prefix: item.prefix }),
                      matches: convertItems(item.children), // Recursively convert children
                 };
                 espansoItems.push(espansoGroup);
            }
             // TODO: Handle '!include' items if we support representing them internally
        });
        return espansoItems;
    };

    // Start conversion from the root group's children
    espansoMatches.push(...convertItems(internalConfig.root.children));

     // Include global settings if any
     const espansoData: any = {
         matches: espansoMatches,
         // ... add global settings
     };
     if (internalConfig.globalSettings) {
         Object.assign(espansoData, internalConfig.globalSettings);
     }


    return espansoData;
}


// 获取 Espanso 支持的内置变量和功能列表 (不变)
export function getAvailableVariables(): string[] {
    return ['date', 'clipboard', 'time', 'os', 'hostname', 'username', 'email', 'path', 'selection', 'form', 'key', 'shell']; // Example list
}

// 获取 Espanso 支持的脚本类型或函数列表 (不变)
// export function getAvailableScriptTypes(): string[] { ... }


// 实现规则预览逻辑 (不变)
export function generatePreview(rule: EspansoRule): string {
    let previewText = rule.content;
    // TODO: Implement logic to replace variables like {{date}}, {{clipboard}} etc. with sample data
    // TODO: Implement logic to simulate script execution for script type
    // TODO: Handle rich text/html rendering if possible in a limited preview area
    // TODO: For image type, display a placeholder or thumbnail
    return `Preview of "${rule.trigger}":\n---\n${previewText}\n--- (Note: Preview is a simulation)`;
}

// Helper to add IDs and timestamps recursively if missing during parsing (不变)
export function addIdsAndTimestamps(item: any): any {
    if (typeof item !== 'object' || item === null) {
        return item;
    }

    if (Array.isArray(item)) {
        return item.map(addIdsAndTimestamps);
    }

    const now = Date.now();
    const newItem = {
        ...item,
        id: item.id || generateId(),
        createdAt: item.createdAt || now,
        updatedAt: item.updatedAt || now,
        // Ensure type is set for internal consistency, infer if possible
        type: item.type || (item.trigger ? 'rule' : (item.name && item.children !== undefined ? 'group' : undefined)), // Infer type based on properties
        // Add parentId if not present (easier after initial structure is built)
    };

    // Recursively process children if it's a group or similar structure
    if (newItem.type === 'group' && newItem.children) {
        newItem.children = addIdsAndTimestamps(newItem.children);
    }
     // If the parsed data is the top-level matches array from Espanso, wrap it in a root group
    if (Array.isArray(newItem.matches)) {
        const rootGroup: EspansoGroup = {
            id: 'root',
            type: 'group',
            name: '所有配置',
            createdAt: newItem.createdAt,
            updatedAt: newItem.updatedAt,
            children: addIdsAndTimestamps(newItem.matches), // Process the items in matches array
            parentId: 'root',
             isExpanded: true,
        };
         // Add parentId for top-level children
         rootGroup.children.forEach(child => {
             if (child.type !== 'group') (child as any).parentId = rootGroup.id;
         });

        return { root: rootGroup }; // Return wrapped structure
    }


    // Ensure all internal group items have a children array
    if (newItem.type === 'group' && !newItem.children) {
         newItem.children = [];
    }


    return newItem;
}

// Helper to recursively set parentId after the tree is built (不变)
export function setParentIds(item: EspansoGroup, parentId: string | 'root' = 'root') {
    item.parentId = parentId;
    if (item.children) {
        item.children.forEach(child => {
            if (child.type === 'group') {
                setParentIds(child, item.id);
            } else {
                 (child as any).parentId = item.id; // Add parentId to rules as well
            }
        });
    }
}

```
**注意:** `convertToInternalFormat` 和 `convertToEspansoFormat` 的实现是理解和映射 Espanso YAML 结构的**核心**和**最复杂**的部分。需要仔细对照 Espanso 的官方文档，确保所有 Espanso 支持的规则属性和内容类型都能正确映射。特别是 `replace` 字段的解析和序列化逻辑。如果 Espanso 的分组是通过注释或其他非标准 YAML 方式表示的，这部分逻辑会更复杂。我在这里提供的实现是基于一种可能的简化结构假设，实际开发中需要根据真实的 Espanso YAML 结构进行调整。

**6. 组件设计 (Vue 3 SFC - 详细的编辑表单)**

我们将详细设计 `GroupEditForm.vue` 和 `RuleEditForm.vue` 单文件组件。它们将使用 Nuxt UI 组件构建界面，利用 Vuelidate 进行表单验证，并通过 `props` 接收数据，通过 `emits` 触发保存、取消、删除等操作。

**6.1. `GroupEditForm.vue` 详细设计**

* **Props:**
    * `group: EspansoGroup` - (通过 `defineProps`) 当前要编辑的分组对象。
* **Emits:**
    * `save: (itemId: string, values: Partial<EspansoGroup>) => void` - (通过 `defineEmits`) 保存按钮点击时触发。
    * `cancel: () => void` - (通过 `defineEmits`) 取消按钮点击时触发。
    * `delete: (itemId: string) => void` - (通过 `defineEmits`) 删除按钮点击时触发。
* **内部状态:**
    * 使用 Vue 3 `ref` 或 `reactive` 管理表单数据 (`formState`)。
    * 使用 Vuelidate (`useVuelidate`) 管理验证规则和状态 (`v$`)。
* **表单字段 (使用 Nuxt UI UForm 和相关输入组件):**
    * 使用 `<UForm :state="formState" :schema="groupValidationSchema" @submit="onSubmit">` 包裹表单。
    * **分组名称 (name):** `<UInput v-model="formState.name" />`, 必填。
    * **描述 (label):** `<UTextarea v-model="formState.label" />`, 可选。
    * **公共前缀 (prefix):** `<UInput v-model="formState.prefix" />`, 可选。
    * **其他分组属性:** 如果需要，添加相应的 Nuxt UI 输入组件。
* **验证:**
    * 定义 Vuelidate 验证规则对象 (`groupValidationRules`)，例如使用 `@vuelidate/validators` 的 `required`。
    * 在 `<UForm>` 中使用 `:schema` 绑定 Joi 或 Zod schema (Nuxt UI 支持)，或在提交时手动调用 `v$.value.$validate()`。
* **响应式更新:**
    * 使用 `watch` 监听 `props.group` 的变化，当 `group` prop 改变时，深度拷贝 `props.group` 的值到 `formState`，并调用 `v$.value.$reset()` 重置验证状态。
* **事件处理:**
    * 表单提交 (`@submit`): 触发 `onSubmit` 方法。在 `onSubmit` 中，首先调用 `await v$.value.$validate()` 进行验证。如果验证通过，则触发 `emit('save', props.group.id, formState.value)`。
    * 取消按钮点击 (`@click`): 触发 `emit('cancel')`。
    * 删除按钮点击 (`@click`): 触发 `emit('delete', props.group.id)`。
* **实现细节:**
    * 使用 `v-model` 将 Nuxt UI 输入组件与 `formState` 中的对应属性双向绑定。
    * Nuxt UI 的 `<UFormGroup>` 组件可以方便地显示标签和验证错误信息。

**6.2. `RuleEditForm.vue` 详细设计**

* **Props:**
    * `rule: EspansoRule` - (通过 `defineProps`) 当前要编辑的规则对象。
* **Emits:**
    * `save: (itemId: string, values: Partial<EspansoRule>) => void` - (通过 `defineEmits`) 保存按钮点击时触发。
    * `cancel: () => void` - (通过 `defineEmits`) 取消按钮点击时触发。
    * `delete: (itemId: string) => void` - (通过 `defineEmits`) 删除按钮点击时触发。
* **内部状态:**
    * 使用 Vue 3 `ref` 或 `reactive` 管理表单数据 (`formState`)。
    * 使用 `ref` 管理当前选中的内容类型 (`currentContentType`)。
    * 使用 Vuelidate (`useVuelidate`) 管理验证规则和状态 (`v$`)。
* **表单字段 (使用 Nuxt UI UForm 和各种组件):**
    * 使用 `<UForm :state="formState" :schema="ruleValidationSchema" @submit="onSubmit">`。
    * **缩写语 (trigger):** `<UInput v-model="formState.trigger" />`, 必填。
    * **描述 (label):** `<UInput v-model="formState.label" />`, 可选。
    * **区分大小写 (caseSensitive):** `<UToggle v-model="formState.caseSensitive" />`, 可选。
    * **整词匹配 (word):** `<UToggle v-model="formState.word" />`, 可选。
    * **应用限制 (apps):** `<USelectMenu v-model="formState.apps" multiple :options="availableApps" />`, 可选。`availableApps` 列表可以从 Pinia store 或 props 获取。
    * **优先级 (priority):** `<UInput v-model.number="formState.priority" type="number" />`, 可选。
    * **快捷键 (hotkey):** `<UInput v-model="formState.hotkey" />`, 可选。
    * **标签 (tags):** 自定义标签输入组件 (例如，使用 `<UInput>` 配合 `<UBadge>` 列表)，支持添加和删除，可选。
    * **展开内容类型 (contentType):** `<USelect v-model="currentContentType" :options="contentTypes" />` 或 `<URadioGroup v-model="currentContentType" :options="contentTypes" />`。`contentTypes` 包含 Espanso 支持的类型。
    * **展开内容 (content):** **根据 `currentContentType.value` 动态渲染不同的输入组件 (使用 `v-if` 或 `<component :is="...">`):**
        * **纯文本:** `<UTextarea v-model="formState.content" ref="contentEditorRef" />`。
        * **富文本:** 集成 Vue 封装的富文本编辑器组件 (如 `tiptap-vue` 或 `@vueup/vue-quill`)，并将其值与 `formState.content` 同步。需要 `ref="contentEditorRef"`。
        * **HTML:** `<UTextarea v-model="formState.content" :rows="10" ref="contentEditorRef" />` 或集成 Vue 代码编辑器组件 (如 `vue-codemirror`)。
        * **脚本:** 集成 Vue 代码编辑器组件，支持语法高亮。`ref="contentEditorRef"`。
        * **图片:** 创建自定义图片上传组件，使用 `<UInput type="file">` 或拖拽区域，读取文件并转换为 Base64 存储到 `formState.content`。
        * **表单/剪贴板/Shell/按键:** 根据 Espanso 的具体格式，设计相应的 Nuxt UI 输入组合来构建所需的字符串或 JSON 结构，并存储到 `formState.content`。
* **插入按钮 (时间、变量、剪贴板、系统等):**
    * 按钮 `@click` 事件触发方法，该方法获取 `contentEditorRef.value` (对应当前激活的编辑器实例)。
    * 调用编辑器实例提供的方法 (或手动操作 DOM selection) 在光标位置插入 Espanso 变量占位符 (如 `{{date}}`)。
    * 可用变量列表 (`availableVariables`) 从 `espanzo-utils` 获取，可以使用 `<UPopover>` 展示。
* **预览按钮:**
    * `@click` 触发方法，获取当前 `formState.value`。
    * 调用 `espanzo-utils` 中的 `generatePreview` 函数。
    * 使用 `<UModal>` 或类似组件显示预览结果。
* **验证:**
    * 定义 Vuelidate 验证规则 (`ruleValidationRules`)。`content` 字段的验证可能需要根据 `currentContentType.value` 设置动态规则。
* **响应式更新:**
    * 使用 `watch` 监听 `props.rule` 变化，深度拷贝到 `formState`，更新 `currentContentType`，并调用 `v$.value.$reset()`。
    * 使用 `watch` 监听 `currentContentType` 变化，可能需要清空或转换 `formState.content` 的值。
* **事件处理:**
    * 表单提交 (`@submit`): 触发 `onSubmit` 方法。验证通过后，**可能需要先根据 `currentContentType` 将 `formState.content` 转换回 Espanso 的 `replace` 结构 (调用 utils 函数)**，然后触发 `emit('save', props.rule.id, processedFormState)`。
    * 取消按钮点击 (`@click`): 触发 `emit('cancel')`。
    * 删除按钮点击 (`@click`): 触发 `emit('delete', props.rule.id)`。
* **实现细节:**
    * 集成第三方编辑器并使其与 Vuelidate 配合可能需要自定义逻辑或包装器组件。
    * 图片上传需要处理 File API 和 Base64 编码。
    * Espanso 特定类型 (form, clipboard, shell, key) 的界面设计和数据结构转换是关键。

**7. 关键功能实现细节 (补充)**

* **YAML 加载和保存的转换细节：**
    * **加载 (`convertToInternalFormat`):**
        * 需要读取 YAML 文件内容 (`readFile`)。
        * 使用 `js-yaml` 解析为 JavaScript 对象 (`parseYaml`)。
        * 遍历解析后的对象，识别出规则、分组和其他可能的 Espanso 配置项（如 `!include`）。
        * 将识别出的规则和分组转换为我们内部的 `EspansoRule` 和 `EspansoGroup` 结构，并生成唯一的 `id`，添加 `createdAt` 和 `updatedAt` 时间戳。
        * 将顶层的规则和分组放入一个虚拟的根分组 (`root`) 的 `children` 数组中。
        * 处理 Espanso 规则中的 `replace` 字段，根据其内容结构（是纯文本、HTML 标签、脚本开头、Base64 字符串等）来判断 `contentType` 并填充到我们内部的 `content` 字段。
        * 递归处理嵌套结构（如果 Espanso 支持）。
        * 添加 `parentId` 属性到每个项目，指向其父分组的 ID。
    * **保存 (`convertToEspansoFormat` 和 `serializeYaml`):**
        * 从 Zustand store 获取内部 `EspansoConfig` 对象。
        * 遍历 `config.root.children`，递归地将内部的 `EspansoRule` 和 `EspansoGroup` 结构转换回 Espanso YAML 所需的对象结构。
        * 将内部的 `contentType` 和 `content` 组合并格式化回 Espanso 的 `replace` 字段。这需要根据 `contentType` 进行不同的处理（例如，脚本类型可能需要在内容前后加上 `|` 和换行符）。
        * 如果支持管理 Espanso 全局设置，也要将其序列化到顶层。
        * 使用 `js-yaml` 将 JavaScript 对象序列化为 YAML 字符串 (`serializeYaml`)。
        * 将 YAML 字符串写入文件 (`writeFile`)。
* **拖拽排序 (VueDraggableNext):**
    * 在 `MiddlePane.vue` 中，使用 `vue-draggable-next` 提供的 `<draggable>` 组件来包裹需要排序的列表（如根片段列表或分组内的子项列表）。
    * 将列表数据 (例如从 Pinia store 获取的 `config.root.children` 或某个 `group.children`) 绑定到 `<draggable>` 组件的 `v-model` 或 `:list` prop 上。
    * 为每个列表项设置唯一的 `:key` 属性 (通常是 `item.id`)。
    * 监听 `<draggable>` 组件的 `@end` 或 `@change` 事件。当拖拽操作完成时，这些事件会被触发。
    * 在事件处理函数中，从事件对象 (`event`) 中提取必要的信息：
        * 被拖拽项的 ID (`event.item.dataset.id` 或通过 `event.oldIndex` 从原始数组获取)。
        * 目标容器/分组的信息 (可以通过 `event.to` 获取目标 DOM 元素，然后查找其关联的分组 ID)。
        * 放置的位置信息 (`event.newIndex`, `event.oldIndex`)。
        * **注意:** 需要仔细设计如何从 DOM 或事件数据中可靠地获取目标分组 ID 和精确的放置位置 ('before', 'after', 'into')。可能需要在 `<draggable>` 元素或其父元素上添加 `data-group-id` 等属性。
    * 根据提取的信息，确定 `draggedItemId`, `targetItemId` (可能是相邻项的 ID 或目标分组的 ID) 和 `position` ('before', 'after', 'into')。
    * 调用 Pinia store 的 `moveItem` action，将这些信息传递进去。
    * `moveItem` action (已在 Pinia Store 部分更新) 负责处理状态更新逻辑 (查找、移除、插入)。VueDraggableNext 会自动处理 DOM 的更新，但状态更新需要手动触发。
        1.  找到 `draggedItemId` 对应的项目，并从其原父节点的 `children` 数组中移除。这需要上面提到的 `removeItemById` 工具函数。
        2.  找到 `targetItemId` 对应的项目或目标分组。
        3.  根据 `position`（'before', 'after', 'into'），将 `draggedItem` 插入到目标位置。
            * `before`/`after targetItemId`: 在 `targetItemId` 所在数组中找到其索引，然后在其前面或后面插入。
            * `into targetGroupId`: 找到 `targetGroupId` 对应的分组，将 `draggedItem` 添加到该分组的 `children` 数组中。如果分组已展开，可以插入到顶部；如果折叠，插入到子数组末尾或标记为在折叠组内。
        4.  更新受影响的分组（原父分组和新父分组）的 `updatedAt` 时间戳。
        5.  使用 Immer 确保状态更新是不可变的。
* **应用限制 (Application Targeting)：**
    * 在 `RuleEditForm` 中，为 `apps` 字段使用一个支持多选的组件。
    * 可供选择的应用列表 (`string[]`) 可以是硬编码的常见应用列表，或者通过 uTools API 尝试获取当前系统已安装的应用列表（如果 uTools 提供了这样的 API）。
    * 选中的应用名称数组存储在规则对象的 `apps` 字段中。
* **标签管理 (Tags)：**
    * 在 `RuleEditForm` 中，为 `tags` 字段创建一个自定义组件。
    * 该组件包含一个输入框和一个区域来显示已添加的标签（使用 Shadcn UI 的徽章 `Badge` 组件）。
    * 用户在输入框输入文本后按回车键，将文本作为新标签添加到标签数组中，并清除输入框。
    * 点击已添加的标签徽章可以将其移除。
    * 标签数组存储在规则对象的 `tags` 字段中。
    * `LeftPane` 需要获取所有规则中使用的唯一标签列表 (`getAllTags` Selector) 并展示，点击标签时更新 `middlePaneFilterTags` 状态。
    * `MiddlePane` 需要根据 `middlePaneFilterTags` 状态过滤显示片段列表。

**8. 技术实施计划与实习生任务分解 (Vue 3 版本)**

以下是将项目分解为一系列可管理的任务，适合实习生逐步完成。每个任务都应指定负责的文件和核心目标。

1.  **基础环境搭建 (负责人：实习生，指导：你)**
    * 安装所有必要的技术栈依赖 (`npm install vue@next pinia @nuxt/ui @vuelidate/core @vuelidate/validators vuedraggable-next js-yaml uuid`)。
    * 配置 Nuxt UI (通常在 `nuxt.config.ts` 或类似文件中)。确保 Tailwind CSS 正常工作。
    * 验证 Vite 开发服务器可以正常启动并运行 Vue 应用。
2.  **核心数据模型实现 (负责人：实习生，指导：你)** (不变)
    * 创建 `src/types/espanzo-config.ts` 文件，精确定义 `BaseItem`, `EspansoRule`, `EspansoGroup`, `EspansoConfig`, `UIState` 接口。
3.  **平台服务层实现 (负责人：实习生，指导：你)** (不变)
    * 修改 `public/preload/services.js`，实现 `readFile`, `writeFile`, `showOpenDialog` 函数，并确保 `js-yaml` 在 preload 环境中可用。
    * 更新 `public/preload/package.json` 添加 `js-yaml` 依赖。
4.  **ESPANSO 工具函数基础实现 (负责人：实习生，指导：你)** (不变)
    * 创建 `src/utils/espanzo-utils.ts`。
    * 实现 `parseYaml`, `serializeYaml`, `generateId`, `findItemById`, `walkTree`, `addIdsAndTimestamps`, `removeItemById`, `insertItemAtIndex` 的基础版本。
    * 实现 `convertToInternalFormat` 和 `convertToEspansoFormat` 的初步版本。**强调这部分后续需要详细完善。**
    * 实现 `getAvailableVariables` (硬编码列表)。
    * `generatePreview` 函数先返回一个占位符字符串。
5.  **Pinia Store 基础实现 (负责人：实习生，指导：你)**
    * 创建 `src/store/useEspansoStore.ts` 文件。
    * 使用 `defineStore` 创建 store，定义 `state`, `getters`, `actions`。
    * 实现 `loadConfig` Action：调用 `showOpenDialog`, `readFile`, `parseYaml`, `convertToInternalFormat`, `addIdsAndTimestamps` 更新 `state`。处理加载失败。
    * 实现 `saveConfig` Action：调用 `convertToEspansoFormat`, `serializeYaml`, `writeFile` 保存文件。处理保存失败。
    * 实现 `selectItem` Action。
    * 实现 `setLeftMenuCollapsed` Action。
    * 实现 `addItem`, `updateItem`, `deleteItem` Action 的基础逻辑（调用 Utils 函数更新 `state`）。
    * 实现 `moveItem` Action 的基础逻辑（调用 `removeItemById`, `insertItemAtIndex` 更新 `state`）。
    * 实现 `selectedItem` 和 `allTags` Getters。
6.  **UI 骨架构建 (负责人：实习生)**
    * 修改 `src/App.vue`，在 `<script setup>` 中导入并使用 Pinia store (`useEspansoStore`)。在 `onMounted` (或 uTools 插件入口逻辑处) 调用 `loadConfig` Action。渲染 `Layout.vue` 组件。
    * 创建 `src/components/Layout.vue`，使用 Nuxt UI 组件 (如 `<UContainer>`, `<UCard>`) 构建三栏布局。
    * 创建 `src/components/LeftPane.vue`，使用 Nuxt UI 组件作为菜单栏骨架。
    * 创建 `src/components/MiddlePane.vue`，使用 Nuxt UI 组件 (如 `<UAccordion>` 或自定义列表) 作为列表骨架，从 store 中获取 `config.root.children` 并使用 `v-for` 初步渲染。
    * 创建 `src/components/RightPane.vue`，根据 store 中的 `selectedItemId` 条件渲染不同的占位符文本或编辑组件。
7.  **分组编辑功能实现 (负责人：实习生)**
    * 创建 `src/components/GroupEditForm.vue`。
    * 使用 `<script setup>`, `ref`/`reactive`, `defineProps`, `defineEmits`。
    * 使用 Nuxt UI `<UForm>`, `<UInput>`, `<UTextarea>` 构建表单 UI，并用 `v-model` 绑定表单状态。
    * 使用 Vuelidate 定义验证规则和 `useVuelidate`。
    * 在 `watch` 中监听 `props.group` 变化并更新表单状态、重置验证。
    * 实现表单提交 (`@submit`)、取消、删除按钮的逻辑，触发相应的 `emits`。
8.  **规则编辑功能实现 (基础部分) (负责人：实习生)**
    * 创建 `src/components/RuleEditForm.vue`。
    * 使用 `<script setup>`, `ref`/`reactive`, `defineProps`, `defineEmits`。
    * 使用 Nuxt UI `<UForm>`, `<UInput>`, `<UTextarea>`, `<UToggle>`, `<USelect>` 构建基础表单 UI。
    * 使用 Vuelidate 定义验证规则。
    * 在 `watch` 中监听 `props.rule` 变化并更新表单状态、重置验证。
    * 连接 Save, Cancel, Delete 按钮到相应的 `emits`。
    * 实现 `contentType` Select (`<USelect>`) 的值变化时，更新本地 `ref` (`currentContentType`)。
    * 使用 Nuxt UI `<UTabs>` 实现内容编辑区域的切换，先只在“纯文本” Tab 中放一个 `<UTextarea>`。
9.  **拖拽排序功能实现 (负责人：实习生，重点指导)**
    * 在 `MiddlePane.vue` 中引入 `vue-draggable-next` 的 `<draggable>` 组件。
    * 将列表数据绑定到 `<draggable>` 的 `v-model` 或 `:list`。
    * 监听 `@end` 或 `@change` 事件。
    * 在事件处理函数中解析事件对象，获取 `draggedItemId`, `targetItemId`, `position` 等信息。**需要仔细指导如何从事件和 DOM 中获取这些信息。**
    * 调用 Pinia store 的 `moveItem` Action。
    * 在 `MiddlePane.vue` 渲染时，根据 `config.root.children` 递归渲染 `<draggable>` 列表。
10. **高级规则编辑功能实现 (负责人：实习生，重点指导)**
    * 完善 `RuleEditForm.vue`。
    * 实现应用限制 (apps): 使用 Nuxt UI `<USelectMenu multiple>`。
    * 实现标签管理 (tags): 创建自定义 `TagInput.vue` 组件 (使用 `<UInput>` 和 `<UBadge>`)，集成到 `RuleEditForm.vue`。
    * 完善内容类型编辑区域：
        * **富文本/HTML/脚本：** 集成 Vue 封装的编辑器组件 (如 `tiptap-vue`, `vue-codemirror`)。**指导如何将第三方编辑器与 Vuelidate 集成。**
        * **图片：** 实现图片上传组件，转换为 Base64。
    * 实现插入变量/时间/剪贴板按钮：获取 `availableVariables`，实现点击按钮在内容编辑器 (`ref`) 中插入文本。
    * 实现预览按钮：调用 `generatePreview`，使用 `<UModal>` 显示结果。
11. **工具函数和格式转换完善 (负责人：你 或 经验更丰富的开发者，指导实习生理解)** (不变)
    * **仔细研究 Espanso 官方文档，精确实现 `convertToInternalFormat` 和 `convertToEspansoFormat`。**
    * 完善 `generatePreview` 函数。
12. **左侧菜单和标签过滤实现 (负责人：实习生)**
    * 完善 `LeftPane.vue`。
    * 使用 Pinia getter (`allTags`) 获取所有标签。
    * 渲染标签列表，点击标签调用 Pinia action 更新 `middlePaneFilterTags` 状态。
    * 在 `MiddlePane.vue` 中根据 `middlePaneFilterTags` 状态过滤渲染列表项。
13. **导入/导出功能实现 (负责人：实习生，指导：你)**
    * 在 UI 中添加导入/导出按钮。
    * 导入：调用 `showOpenDialog`, `readFile`, `parseYaml`, `convertToInternalFormat`，调用 Pinia action 更新 store。
    * 导出：从 Pinia store 获取 `config`，调用 `convertToEspansoFormat`, `serializeYaml`, `writeFile`。
14. **错误处理和通知 (负责人：实习生)**
    * 在文件操作、YAML 处理、表单验证等地方添加 try...catch 块。
    * 使用 uTools 的 `showNotification` 或 Nuxt UI 的通知组件 (`useToast`) 显示提示。
    * 利用 Vuelidate 的错误状态和 Nuxt UI `<UFormGroup>` 显示表单验证错误。
15. **测试和优化 (负责人：你 和 实习生)** (不变)
    * 进行功能测试。
    * 检查跨平台兼容性。
    * 进行代码审查。
    * 进行性能优化。

**9. 指导与支持策略**

* **明确的任务分配：** 每次只分配少量具体、边界清晰的任务。
* **代码示例：** 对于复杂的功能（如 Zustand Actions 中的 Immer 使用、React DnD 实现、自定义表单控件），提供简洁的代码示例。
* **数据结构解释：** 反复强调内部数据模型的结构和不同字段的含义，以及它与 Espanso YAML 的映射关系。
* **逐步集成：** 鼓励实习生逐步集成不同的库和功能，先实现核心流程，再添加高级特性。
* **定期沟通：** 每天或每隔一段时间进行简短的站会或交流，了解进展、解决问题、提供指导。
* **重点代码审查：** 对包含业务逻辑较多或容易出错的部分（如 Zustand Actions, YAML 转换 Utils, DnD 实现）进行更详细的代码审查。
* **鼓励提问：** 创造一个开放的环境，让实习生敢于提问，即使是看似简单的问题。

**10. 风险与缓解**

* **风险：** Espanso YAML 配置文件格式的复杂性和未完全覆盖性。特别是高级功能（form, script, key, shell）的 `replace` 结构可能非常多样。
    * **缓解：** 投入专门时间深入研究 Espanso 官方文档中关于所有可配置项和 `replace` 字段结构的详细说明。将 YAML 解析和序列化逻辑视为核心且高风险部分，由你或经验丰富的开发者主导设计和关键代码实现，并提供详细的规范给实习生。如果某些高级功能过于复杂，可以考虑在第一阶段 MVP 中暂不完全支持，后续迭代添加。
* **风险：** 实习生在实现涉及状态更新和组件交互的复杂业务逻辑时遇到困难（如拖拽排序、动态表单）。
    * **缓解：** 将这些复杂功能分解为更小的步骤。提供详细的伪代码或实现思路。利用 Zustand 和 React Hook Form 提供的模式来封装逻辑。在实现过程中进行密切的代码审查和手把手指导。确保状态更新使用 Immer，避免不可变性问题。
* **风险：** 第三方库（React DnD, 富文本编辑器等）的集成和与 React Hook Form 的配合。
    * **缓解：** 提供清晰的集成示例。指导实习生查阅第三方库和 React Hook Form 的官方文档。必要时，可以先由你实现一个简单的集成示例组件，供实习生参考。
* **风险：** 跨平台文件路径和权限问题。
    * **缓解：** 在 Preload Script 中处理文件路径时，使用 Node.js 的 `path` 模块 (`path.join`) 来构建路径，以保证跨平台兼容性。处理文件写入时，考虑潜在的权限问题，并在 Preload Script 中捕获并通知用户。

通过这份详细的技术方案，你应该能够有效地指导你的实习生完成 ESPANSO 配置管理工具的开发。祝项目成功，早日实现你的梦想！

---